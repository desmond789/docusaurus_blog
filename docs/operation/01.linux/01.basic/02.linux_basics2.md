---
description: linux基础知识简介
# id: 02.linux_basics
title: linux基础知识二
# tags:
#   - Demo
#   - Getting started
---
## 实用指令

**目录相关命令：**

* pwd：Print Working Directory，显示当前工作目录的绝对路径。
* ls：-a：显示当前目录所有的文件和目录，包括隐藏的；
  * -l：以列表的方式显示信息。
  * -h：友好方式显示信息。
* cd：cd ~：回到自己的家目录；cd …：回到当前目录的上一级目录。
* mkdir：创建目录；-p：创建多级目录。
* rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。
* cp：拷贝文件到指定目录；
  * -r：递归复制整个文件夹。强制覆盖不提示的方法：cp命令改为\cp
* rm：移除文件或目录；
  * -r：递归删除整个文件夹；
  * -f：强制删除不提示。
* mv：移动文件与目录或重命名，两种功能！
* touch：创建空文件。可以一次性创建多个文件
* ln 给文件创建一个软连接
  * ln -s [源文件或目录] [软连接名]

**文件查看**

* cat：查看文件内容。只能浏览文件，而不能修改文件。
  * -n：显示行号。
  * 结尾加上 | more：分页显示，不会全部一下显示完。
* more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：
  * Space：向下翻一页
  * Enter：向下翻一行
  * q：退出
  * Ctrl + F：向下滚动一屏
  * Ctrl + B：返回上一屏
  * = :输出当前行的行号
  * :f 输出文件名和当前行的行号
* less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。
* head：显示文件的开头部分。-n 5：看前面5行内容。
* tail：输出文件中尾部的内容。
  * -n 5：看后面5行内容。
  * -f：时事追踪该文档的所有更新
* ">"指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。
* ">>"指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。
* echo：输出内容到控制台。
* history：查看历史指令

**时间和日期**

* date：显示当前日期和时间
  * date “+%Y”：显示当前年份
  * date “+%d”：显示当前月份
  * date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒
  * 设置日期：date -s 字符串时间
* cal：查看日历指令；
  * cal [月] [年份]：显示某一年或月的日历

**索查找类**

**find**

用于在文件系统中搜索文件和目录，可以根据多个条件执行搜索操作。

```
find /path/to/search -options criteria
```

* `/path/to/search`: 要搜索的起始目录路径。
* `-options`: 可选的搜索选项。
* `criteria`: 搜索条件。

```
find /path/to/search -name "filename"	#按文件名搜索文件
find /path/to/search -type f		#按文件类型搜索
find /path/to/search -type d		#按目录类型搜索
find /path/to/search -size +10M		#按文件大小搜索，搜索大小大于10兆字节的文件。+ ：大于，- ：小于，没有符号是等于。
find /path/to/search -perm 644		#按文件权限搜索，搜索权限为644的文件
find /path/to/search -user username	#按用户搜索，搜索属于指定用户的文件
find /path/to/search -group groupname	#按组搜索，搜索属于指定用户组的文件
find /path/to/search -mtime -7		#按修改时间搜索，搜索在最近7天内修改的文件。-mtime +7 表示7天前，-mtime 0 表示今天。
find /path/to/search -atime -7		#按访问时间搜索，搜索在最近7天内访问的文件
find /path/to/search -ctime -7		#按创建时间搜索，搜索在最近7天内创建的文件
find /path/to/search -maxdepth 2	#按深度搜索，限制搜索的深度，这里是2层目录
find /path/to/search -exec command {} \;	#执行命令，对搜索到的每个文件执行指定的命令。{} 会被替换为文件名，\; 表示命令结束。
```

**示例：**

```
find /path/to/search -name "*.txt"			#搜索所有 .txt 文件
find /path/to/search -size +100M			#搜索大小超过100兆字节的文件
find /path/to/search -name "*.jpg" -user username	#搜索由特定用户拥有的 .jpg 文件
find /path/to/search -name "*.log" -mtime -7		#搜索在最近7天内修改的 .log 文件
find /path/to/search -size -1M -exec rm {} \;		#搜索并删除大小小于1兆字节的文件
```

**locate**

用于快速定位文件和目录的命令。它通过搜索一个预建的数据库而不是实时查找文件系统，因此速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。在第一次运行之前，必须使用updatedb指令创建locate数据库。

在第一次运行之前，必须使用updatedb指令创建locate数据库。

```
updatedb		#更新数据库
locate filename		#查找包含指定文件名或目录名的路径
locate -i filename	#大小写不敏感的搜索
locate -b filename	#显示数据库中所有匹配项的路径
locate -n 5 filename	#限制搜索结果数量为5个
locate -S		#显示数据库的更新时间
```

**grep**

用于在文本文件中搜索指定模式的强大工具。它可以根据正则表达式或简单的字符串匹配来查找文件中的内容。

**grep [选项] pattern file**

* `-v`: 显示不包含匹配模式的所有行。
* `-n`: 显示包含匹配模式的所有行，并显示行号。
* `-o`: 只显示匹配模式的部分，而不是整行。
* `-r`: 递归地在指定目录及其子目录中搜索匹配模式的文本。
* `-i`: 进行大小写不敏感的搜索。
* `-c`: 显示匹配模式的行数。
* `-A N`: 显示匹配行之后 N 行。
* `-B N`: 显示匹配行之前 N 行。
* `-C N`: 显示匹配行及其上下文（前后 N 行）。

```
grep pattern file
grep -v pattern file
grep -n pattern file
grep -o pattern file
grep -r pattern directory
grep -B N pattern file
grep -A N pattern file
grep -C N pattern file

grep "pattern" filename		#在文件中搜索匹配模式
grep -r "pattern" directory	#递归搜索目录中的所有文件
grep -i "pattern" filename	#忽略大小写搜索
grep -C 2 "pattern" filename	#显示匹配行及其上下文
grep -c "pattern" filename	#统计匹配模式的行数
grep pattern *.txt		#在指定文件类型的文件中搜索匹配模式的文本
grep -vc pattern file		#显示不匹配模式的行数
```

**压缩和解压**

**gzip 和 gunzip**

```
gzip filename		#压缩指定的文件。该命令将生成一个压缩后的文件，并原始文件保留。
gzip -k filename	#保留原始文件，即不删除源文件。
gzip -9 filename	#指定压缩级别。级别范围是1到9，1表示最低压缩级别，9表示最高压缩级别。
gzip -r directory	#递归地压缩目录中的所有文件
gzip -q filename	#不显示压缩比

gunzip filename.gz	#解压缩指定的 gzip 压缩文件。该命令将生成一个解压后的文件，并原始压缩文件保留。
gunzip -k filename.gz	#保留原始压缩文件
gunzip -r directory	#归地解压缩目录中的所有 gzip 压缩文件
gunzip -q filename.gz	#不显示解压信息
```

**zip 和 unzip**

```
zip archive.zip file1 file2 file3	#创建名为archive.zip的ZIP文件，并将指定的文件file1file2file3添加到ZIP文件中
zip -r archive.zip directory		#递归地将目录 directory 添加到ZIP文件中
zip -v archive.zip file1 file2		#显示详细的添加文件信息
zip -e archive.zip file1 file2		#设置密码保护ZIP文件
zip -0 archive.zip file1 file2		#使用 -0 选项不压缩文件，只打包成ZIP文件

unzip archive.zip			#解压缩名为 archive.zip 的ZIP文件到当前目录
unzip archive.zip -d /path/to/directory	#指定解压缩目录
unzip -l archive.zip			#列出ZIP文件的内容，包括文件名、压缩比、时间戳等信息
unzip archive.zip file1 file2		#解压指定文件，而不是解压整个ZIP文件
unzip -o archive.zip			#覆盖已存在的文件
unzip -v archive.zip			#显示详细的解压信息
unzip -P password archive.zip		#解压加密的ZIP文件
```

**tar	用于创建和提取归档文件的工具**

* `-c`: 创建新的归档文件。
* `-v`: 显示详细信息。
* `-f`: 指定归档文件的名称。
* `-z`: 使用 gzip 压缩。
* `-j`: 使用 bzip2 压缩。
* `-x`: 提取归档文件的内容。
* `-t`: 列出归档文件的内容。
* `-C`: 切换到指定目录并创建归档文件。
* `--exclude`：排除符合指定模式的文件或目录。
* `-r`: 将新文件追加到现有归档中。

```
tar -cvf archive.tar file1 file2 directory	#创建 tar 归档文件
tar -czvf archive.tar.gz file1 file2 directory	#创建 tar 归档文件并压缩（gzip）
tar -cjvf archive.tar.bz2 file1 file2 directory	#创建 tar 归档文件并压缩（bzip2）

tar -xvf archive.tar			#提取 tar 归档文件
tar -xzvf archive.tar.gz		#提取 tar 归档文件并解压缩（gzip）
tar -xjvf archive.tar.bz2		#提取 tar 归档文件并解压缩（bzip2）

tar -tvf archive.tar					#列出 tar 归档文件内容
tar -cvf archive.tar -C /path/to/directory .		#切换到/path/to/directory并创建该目录下所有文件的归档文件
tar --exclude=pattern -cvf archive.tar directory	#归档directory时，排除符合指定模式的pattern文件或目录
tar -rvf archive.tar newfile				#将newfile追加到现有归档中
tar -xvf archive.tar file1 file2			#提取归档文件中的file1 file2
```

**磁盘相关工具**

**`df`（disk free）**

是一个用于显示文件系统磁盘空间使用情况的命令。它可以用于查看挂载的文件系统的剩余空间、已用空间和总空间等信息。

```
df -h		#显示详细信息
df -h /dev/sda1	#显示特定文件系统
df -a		#显示所有文件系统，包括虚拟文件系统
df -i		#显示inode（索引节点）的使用情况
df -l		#只显示本地文件系统，而不显示NFS等网络文件系统
df -T		#显示文件系统的类型
df -a -h --output=source,target,size,used,avail,pcent	#使用--output选项指定要显示的列，可以选择性地显示源、目标、大小、已用空间、剩余空间和使用百分比等信息。
df -t ext4	#只显示指定类型的文件系统，这里以ext4为例
```

**`du` 命令（Disk Usage）**

用于查看文件或目录磁盘使用情况的命令。它会递归地显示指定目录及其子目录的磁盘使用量。

```
du [选项] [文件或目录]		#如果不指定文件或目录，默认显示当前目录的磁盘使用情况。
du filename			#显示指定文件或目录的磁盘使用情况。如果是目录，会递归显示其下所有子目录的磁盘使用情况。
du -h				#友好显示文件大小
du -s				#指定目录占用大小汇总
du -a				#指定目录占用大小汇总
du -c				#只显示总磁盘使用量，不显示每个文件或目录的详细使用情况
du --max-depth=N		#指定递归深度，只显示到指定深度的目录
du | sort -n			#将 du 的输出通过管道传递给 sort -n 命令，按大小升序排序显示。
du --block-size=1M		#指定文件大小的显示格式，这里以兆字节为单位。
du --apparent-size		#显示每个文件的实际大小，而不是磁盘上所占用的大小。
du --exclude=pattern		#排除符合指定模式的文件或目录
```

**`tree` 命令**

```
tree [选项] [目录]		#如果不指定目录，默认会显示当前目录的树状结构
tree				#显示当前目录的树状结构，包括所有子目录和文件
tree -F				#以图形符号（例如 / 表示目录，* 表示可执行文件）显示文件和目录的类型。
tree /path/to/directory		#指定要显示树状结构的目录
tree -d				#只显示目录，而不显示文件
tree -h				#友好显示文件和目录的大小
tree -l				#显示每个文件和目录的详细信息，包括权限、所有者、大小等。
tree -L 2			#限制树状结构的深度，只显示到指定层级
tree > tree_output.txt		#将树状结构的输出保存到文件中
tree --prune -P '*.txt' --ignore 'directory_name'	#使用 --prune 选项可以排除指定文件或目录，并使用 -P 选项指定要包含的文件模式，--ignore 选项指定要排除的文件或目录。
tree -s				#显示目录大小
```

**常用指令：**

```
ls -l /home | grep "^-" | wc -l			#统计/home文件夹下文件的个数
ls -l /home | grep "^d" | wc -l			#统计/home文件夹下目录的个数
ls -lR /home | grep "^-" | wc -l		#统计/home文件夹下文件的个数，包括子文件夹里的
ls -lR /home | grep "^d" | wc -l		#统计文件夹下目录的个数，包括子文件夹里的
tree
```

## Crontab定时任务

Crontab（Cron Table的缩写）是用于在Unix和类Unix操作系统上定期执行任务的工具。它允许用户在指定的时间和日期执行命令、脚本或程序。

日志文件:  ll /var/log/cron*
编辑文件： vim /etc/crontab
进程：ps -ef | grep crond  ==> /etc/init.d/crond restart
作用：定时备份，实时备份

### 常见命令参数

```
usage:  crontab [-u user] file
        crontab [-u user] [ -e | -l | -r ]
                (default operation is replace, per 1003.2)
        -e      (edit user's crontab)
        -l      (list user's crontab)
        -r      (delete user's crontab)
        -i      (prompt before deleting user's crontab)
        -s      (selinux context)
```

### 定时任务分类

Linux下的任务调度分为两类，**系统任务调度**和**用户任务调度**。

* 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc/crontab文件，这个就是系统任务调度的配置文件。root用户的任务调度操作可以通过 `crontab –uroot –e`来设置，也可以将调度任务直接写入 ``/etc/crontab``文件。如果要定义一个定时重启系统的任务，就必须将任务放到 ``/etc/crontab``文件，即使在root用户下创建一个定时重启系统的任务也是无效的。
* 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。

在crontab 文件都被保存在/var/spool/cron目录中。其文件名与用户名一致

```
vim /etc/crontab
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
```

* **SHELL 和 PATH:**

  * `SHELL=/bin/bash`: 指定用于执行crontab文件中命令的shell。
  * `PATH=/sbin:/bin:/usr/sbin:/usr/bin`: 设置cron任务的环境变量搜索路径。
* **MAILTO:**

  * `MAILTO=root`: 定义cron任务的输出应该发送到的邮箱地址，这里设置为root用户的邮箱。或者使用 `* * * * * command >/dev/null 2>&1` 将输出重定向到空设备来禁用邮件通知。
  * 
* **时间字段说明：**

  * `minute`：0到59，表示每小时的哪一分钟执行任务。
  * `hour`：0到23，表示每天的哪一小时执行任务。
  * `day`：1到31，表示每月的哪一天执行任务。
  * `month`：1到12，表示每年的哪一月执行任务。
  * `day_of_week`：0到6，表示星期几（0表示星期天）执行任务。
* **特殊字符：**

  * `*`：代表任意值，例如，`*`在 `minute`字段表示每分钟都执行。
  * `,`：用于分隔多个值，例如，`1,15`在 `day`字段表示每月的1号和15号执行任务。
  * `-`：用于表示范围，例如，`1-5`在 `day`字段表示每月1号到5号执行任务。
  * `/`：用于指定间隔，例如，`*/10`在 `minute`字段表示每隔10分钟执行任务。
* **环境变量：**

  * Crontab任务执行时的环境变量通常是有限的，所以最好使用绝对路径来指定命令和文件。
  * 注意任务的执行环境，包括路径和环境变量。没有shell或程序所需的环境变量，任务可能会不运行，一般都有/bin/bash 类似的shell，或者添加自定义环境变量。
* **日志：**

  * Crontab任务的输出和错误通常被发送到用户的邮箱，可以使用 `MAILTO`来指定邮箱。邮箱也可以为空。
  * 可以通过查看系统日志来获取更多有关cron任务执行的信息，通常位于 `/var/log/syslog`或者类似的文件中。
  * `/var/log/cron * `只会记录是否执行了某些计划的脚本，但是具体执行是否正确以及脚本执行过程中的一些信息则linux会每次都发邮件到该用户下。
* **配置文件：**

  日志保存位置和级别的配置可以通过 `/etc/rsyslog.conf` 或 `/etc/syslog.conf` 文件进行设置。可以修改这些文件以增加或减少 `cron` 日志的详细程度。
* **注意事项**

  * 为了防止环境问题，最好使用绝对路径。
  * 注意任务执行的频率，避免过于频繁的执行。
  * 命令的执行最好用脚本。
  * 定时任务和运行的脚本添加注释

**例子：**

```
0 * * * * command		#每小时执行一次。
0 2 * * * command		#每天凌晨2点执行一次。
30 3 * * 1-5 command		#每周一到周五的凌晨3点30分执行一次。
0 0 1 1 * command		#每年的1月1日零点执行一次。

0 0 * * * /bin/bash /root/sa/backup/backup_system.sh		#每天0点0分运行backup_system.sh服务器备份脚本
*/2 * * * * /bin/bash /usr/bin/ntpstat time.windows.com >/dev/null 2>&1	#每隔2分钟同步一次互联网时间

#添加环境变量
0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
```

## 网络配置

### 相关文件

**网卡文件**

网卡文件位置：/etc/sysconfig/network-scripts/

命名格式：ifcfg-eth0

```
#网卡文件内容
DEVICE=eth0				#网络接口的名称
HWADDR=00:0C:29:11:30:39		#网络接口的硬件地址（MAC 地址）
TYPE=Ethernet				#网络接口的类型
UUID=5ab36190-a5df-4bf1-94d8-6c126afd05f1	#网络接口的 UUID
NM_CONTROLLED=yes			#表示NetworkManager控制这个网络接口，no表示NM不控制，而是由系统的网络服务network服务来管理。
BOOTPROTO=static			#网络接口的引导协议，静态：static，动态：dhcp
IPADDR=192.168.1.2			#静态 IP 地址
NETMASK=255.255.255.0			#子网掩码
GATEWAY=192.168.1.1			#网关的 IP 地址
DNS1=8.8.8.8				#首选DNS地址
DNS2=8.8.4.4				#备用DNS地址
ONBOOT=yes				网络接口是否开机自启，yes:自启，no:不自启
```

**DNS文件**

DNS文件位置：/etc/resolv.conf

```
#DNS配置信息
nameserver 192.168.134.2	#nameserver是域名服务器
```

**主机名文件**

主机名文件位置：/etc/hosts

```
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
127.0.0.1   xxxx
```

### 命令相关

`ip` 命令是用于配置和显示 Linux 操作系统中网络设备、路由、策略路由和隧道的工具。它是 `iproute2` 工具集的一部分，提供了更多功能和灵活性。

**显示网络设备信息**

```
ip link show		#显示简要网络设备信息
ip a			#显示完整网络设备信息，包括接口名称、MAC 地址、状态等。
ip link show up		#只显示处于启用状态的网络设备。
ip link show dev eth0	#显示指定设备（这里是 eth0）的详细信息
ip addr show		#显示所有接口的 IP 地址信息，或ip a
```

**配置网络设备**

```
ip link set dev eth0 up			#启用指定设备。
ip link set dev eth0 down		#禁用指定设备。
ip addr add 192.168.1.2/24 dev eth0	#给指定设备分配IP地址192.168.1.2和子网掩码/24。
ip addr del 192.168.1.2/24 dev eth0	#删除指定设备的IP地址192.168.1.2。
ip link set dev eth0 address XX:XX:XX:XX:XX:XX	#修改指定设备（eth0）的MAC地址。
```

**路由相关**

**显示路由表**

```
ip route show		#显示路由表，包括目标网络、网关、接口等信息，简写：ip r
ip route show default 	#显示默认路由。简写：ip r s default
ip route show table all	#示所有路由表的信息。或ip route show all
```

**静态路由**

```
#添加静态路由，添加到 192.168.2.0/24 网络的静态路由，通过 192.168.1.1 网关，经过 eth0 接口。
ip route add 192.168.2.0/24 via 192.168.1.1 dev eth0
#删除路由，删除路由表中的 192.168.2.0/24 目标。
ip route del 192.168.2.0/24
```

**策略路由**

```
#显示策略路由，显示策略路由规则，包括优先级、源地址、目标地址等信息。简写：ip ru
ip rule show
#添加策略路由规则，添加一个策略路由规则，从源地址 192.168.1.2 到路由表 10。
ip rule add from 192.168.1.2 table 10
```

**显示和配置ARP（Address Resolution Protocol）**

```
ip neigh show		#显示 ARP 表，包括IP地址、MAC地址、接口等信息。简写：ip n

#配置ARP缓存
ip neigh add 192.168.1.1 lladdr 00:11:22:33:44:55 nud permanent dev eth0
```

* `ip neigh add`：添加一个ARP表项。
* `192.168.1.1`：目标 IP 地址。
* `lladdr 00:11:22:33:44:55`：目标 MAC 地址。
* `nud permanent`：设置条目为永久。
* `dev eth0`：指定网络设备。

**显示统计信息**

```
ip -s link		#显示网络设备的详细统计信息，包括接收和发送的数据包数量
ip -s -d link show eth0	#显示指定设备（eth0）的详细信息
ip -s -z link show eth0	#显示设备的统计信息并设置计数器清零
```

* `-s`：显示摘要信息。
* `-d`：显示详细信息。
* `-z`：在显示设备统计信息后将其清零。

**设备多播和广播**

```
ip link set dev eth0 multicast on
ip link set dev eth0 broadcast on
```

* `multicast on`：启用设备的多播功能。
* `broadcast on`：启用设备的广播功能。

**设置VLAN**

```
ip link show type vxlan			#显示 VXLAN 接口。
ip link show type vlan id 10		#显示 VLAN ID 为 10 的 VLAN 接口。
ip link set dev eth0 vf 0 vlan 10	#为 VF（Virtual Function）设置 VLAN ID。

ip link add link eth0 name eth0.10 type vlan id 10	#添加 VLAN
```

* `link eth0`：指定父接口。
* `name eth0.10`：指定 VLAN 接口的名称。
* `type vlan`：指定接口类型为 VLAN。
* `id 10`：指定 VLAN ID。

```
#添加一个 VXLAN 接口
ip link add vxlan0 type vxlan id 100 remote 203.0.113.1 local 203.0.113.2 dev eth0
```

**网络命名空间（netns）**

```
ip netns			#显示所有网络命名空间
ip netns add namespace1
ip netns exec namespace1 command
```

* `ip netns add`：创建一个新的网络命名空间。
* `ip netns exec`：在指定的网络命名空间中执行命令。

**使用 MPLS（多协议标签交换）**

```
ip route add 192.168.2.0/24 via 192.168.1.1 encap mpls 100
```

`encap mpls 100`：将路由封装为 MPLS 报文，标签为 100。

### 其他工具性命令：

**ping**

`ping` 是一个用于测试网络连通性的命令行工具，通常用于确定本地主机与目标主机之间是否能够正常通信。

```
ping example.com	#向example.com发送ICMP Echo请求和ARP请求，等待目标主机响应。如果连接正常，将看到每个响应的时间。

ping -c 5 example.com		#发送 ICMP Echo 请求的次数
ping -i 2 example.com		#发送 ICMP Echo 请求的时间间隔（以秒为单位）
ping -t example.com		#持续 ping
ping -D example.com		#显示每个 ICMP Echo 请求和响应的时间戳
ping -s 1024 example.com	#设置发送的 ICMP Echo 请求中的数据包大小，此处为1024字节
ping -i 5 -a 2 example.com	#设置 Echo 请求的标识符，此处标识符为2
ping -v example.com		#显示每个 ICMP Echo 请求和响应的详细信息

ping -I eth0 example.com	#指定发送 ICMP Echo 请求时使用的源 IP 地址
ping -w 5 example.com		#设置超时时间，即等待目标主机响应的最长时间（以秒为单位）
ping -A example.com &		#后台运行 ping
ping6 example.com		#使用 IPv6 进行 ping

ping -t 10 example.com		#设置 IP 头部的生存时间（TTL），这对于跟踪数据包经过的路由器数量很有用。
ping -R example.com		#显示每一跳的路径信息
ping -p 12345 example.com	#设置 ICMP Echo 请求的源端口号。

ping -M do -s 1472 example.com	#启用 DF（Don't Fragment）标志，通过逐跳的数据包来测量 MTU（最大传输单元）。
ping -a example.com		#使用 FQDN 进行 ping，而不是解析为 IP 地址
ping -q -c 5 example.com	#启用安静模式，只显示最终的统计信息
ping -c 5 example.com | grep "time"	#通过管道传递结果到其他命令
```

**tracert**

`traceroute` 命令通常用于跟踪数据包从源到目的地的路径，同时显示每一跳的延迟。在 Windows 上，对应的命令是 `tracert`（或 `pathping`）。

```
traceroute example.com		#跟踪到 example.com 的路径，并显示每一跳的 IP 地址、主机名（如果可用）和延迟。
traceroute -n example.com	#显示数字 IP 地址而不是尝试解析主机名
traceroute -p 80 example.com	#指定数据包的目标端口号
traceroute -m 15 example.com	#设置最大跃点数，即数据包最多经过多少个路由器。
traceroute -q 3 example.com	#设置每一跳发送的数据包数量
traceroute -w 2 example.com	#设置等待每一跳的超时时间，单位为秒。
traceroute -U example.com	#使用 UDP 数据包进行跟踪
traceroute -T example.com	#使用 TCP 数据包进行跟踪
traceroute -n -I example.com	#显示每一跳的详细信息
traceroute -6 example.com	#使用 IPv6 进行跟踪
traceroute -d example.com	#显示每一跳的时间戳
traceroute -A example.com	#启用 AS（自治系统）路径分析，显示每一跳的自治系统号。
```

**watch**

`watch` 用于周期性地执行指定的命令并显示输出结果。该命令非常适用于需要定期监视某个进程、日志文件、系统状态等情况的场景。

```
watch command	#周期性地执行指定的命令，并在屏幕上显示输出结果。默认情况下，watch 每两秒执行一次指定的命令。

watch -n 5 command	#设置刷新时间间隔，以秒为单位。
watch -t command	#显示每次命令执行的时间
watch -x command	#显示完整的命令及参数

watch -d -t -n 5 'date'			#周期性地显示日期和时间，高亮显示变化的部分。
watch -n 10 'ls -l /path/to/directory'	#执行包含参数的命令。示例每隔 10 秒执行一次 ls -l 命令。
watch -n 3 'ps aux | grep process_name'	#监视通过管道传递的命令
watch -n 2 'tail -n 10 /var/log/syslog'	#监视日志文件的变化

watch -n 1 'for i in {1..5}; do echo $i; sleep 1; done'	#执行简单的 Bash 循环，以便周期性地运行一组命令
watch -d -n 2 'ls -l /path/to/directory'		#实时监控文件或目录的变化
watch -t -n 1 'echo "Timer: $(date)"'			#创建一个简单的定时器，显示当前时间

watch -n 2 'top -b -n 1 | grep "Cpu"'			#实时监控系统的 CPU 使用情况
#显示特定列的输出
watch -n 2 'ps aux --sort=-%cpu | head -n 10 | awk "{print \$1,\$3,\$11}"'
watch -n 3600 'backup_script.sh'			#周期性地执行备份脚本，例如每小时执行一次

watch -n 2 'free -h'		#监控系统内存使用情况
watch -n 2 'df -h'		#实时监控磁盘空间的使用情况
```

**lsof**

`lsof`（List Open Files）是一个用于显示当前系统中已经打开的文件列表的命令。它可以展示哪些进程打开了哪些文件，包括普通文件、目录、设备文件、网络套接字等。

```
lsof			#列出当前系统中所有打开的文件。但请注意，这可能会产生非常大的输出。
lsof -p PID		#指定要列出的进程的 PID
lsof -u username	#列出指定用户的打开文件
lsof /path/to/file	#列出指定文件的打开进程
lsof -i			#列出所有的网络连接，包括套接字和网络文件。
lsof -i :port		#列出指定端口的网络连接
lsof -U			#列出所有的 UNIX 域套接字
lsof +D /path/to/directory	#列出指定目录的打开文件
lsof /mnt		#列出指定文件系统的打开文件,lsof /mnt 将列出所有位于 /mnt 文件系统上的打开文件。
lsof -i4		#列出 IPv4 网络连接, -i6 用于列出 IPv6 网络连接。
lsof -a -d DEL		#显示被删除但仍被进程打开的文件, -a 可以显示符合多个条件的文件，-d DEL 显示被删除但仍被进程打开的文件。
lsof -d 1		#显示文件描述符号为某个值的文件
lsof -t /path/to/fifo	#显示命名管道（FIFO）, 仅显示文件的进程 ID
lsof -V			#显示文件的引用计数, 即有多少个进程打开了该文件。

#示例
lsof -p 1234 		#将列出进程 ID 为 1234 的所有打开文件。
lsof -u user1		#将列出用户名为 "user1" 的所有打开文件。
lsof /var/log/syslog 	#将列出打开 /var/log/syslog 文件的进程。
lsof -i :80 		#将列出所有占用端口 80 的进程。
lsof +D /tmp 		#将列出所有在 /tmp 目录中打开的文件。
lsof -d 1 		#将显示文件描述符号为 1 的文件。
lsof -t /tmp/myfifo 	#将显示命名管道 /tmp/myfifo 的进程 ID。
watch -n 2 lsof		#实时更新 lsof 的输出，每 2 秒执行一次。
```

**ss**

`ss` 命令（Socket Statistics）用于显示套接字统计信息，包括网络连接、路由表、接口统计等。它是 `netstat` 命令的替代品，并提供了更多的功能和性能。

```
ss		#显示系统上所有的套接字信息，包括 TCP、UDP、RAW 和 UNIX 套接字。
ss -t		#显示 TCP 套接字信息
ss -u		#显示 UDP 套接字信息
ss -l		#显示所有处于监听状态的套接字信息
ss -a		#显示所有连接的套接字信息，包括监听和非监听状态。
ss -x		#显示所有的 UNIX 域套接字信息
ss -i		#显示详细的接口统计信息，包括数据包的收发情况。
ss -p		#显示与套接字关联的进程信息
ss -e		#显示详细的进程信息，包括命令和用户。
ss sport = :80	#只显示符合条件的套接字信息，示例显示本地端口为 80 的套接字信息。
ss -t4		#显示 IPv4 的 TCP 套接字信息，-t6 用于显示 IPv6 的 TCP 套接字信息。
ss -s		#显示连接状态的统计信息，包括 ESTAB（已建立）、SYN-SENT（发送 SYN）、SYN-RECV（接收 SYN）等。
ss -r		#显示路由表信息
ss -m		#显示 TCP 内存使用情况
watch -n 1 ss	#时更新套接字信息，每 1 秒执行一次。


ss -p -A process_name	#显示特定进程的套接字信息，其中 process_name 是进程的名称。
ss -p -U username	#显示特定用户的套接字信息，其中 username 是用户名。
ss state FIN-WAIT-1	#state 可以仅显示指定状态的套接字信息，示例显示状态为 FIN-WAIT-1 的套接字信息。
ss dport = :80 or sport = :80	#只显示符合条件的套接字信息。示例显示目标端口或源端口为 80 的套接字信息。
ss state time-wait	#显示处于指定状态的套接字信息，示例显示处于 TIME-WAIT 状态的套接字信息。
ss -t -a -Z		#-Z 选项可以显示 SELinux 安全上下文信息，结合 -t 和 -a 可以显示所有 TCP 套接字信息。
ss -o state all		#显示更详细的 TCP 连接信息，示例显示所有状态的 TCP 连接信息。
watch -n 1 ss -t -a	#实时更新指定类型的套接字信息，每 1 秒执行一次。
ss -t -o state established	#显示已建立连接的 IP 地址和端口，示例显示所有已建立连接的 TCP 地址和端口。
ss -i -e		#显示网络接口的详细信息
ss -tulwn		#显示所有监听的 TCP 和 UDP 连接。
```

**netstat**

用于显示网络状态和连接信息的命令行工具。它可以列出网络接口、路由表、连接状态等信息，用于网络故障排除和监视网络活动。

**显示所有打开的网络连接**

```
netstat -tulpan		#列出所有打开的 TCP 和 UDP 连接的详细信息，包括本地地址、远程地址、状态、进程 ID 等。
```

* `-t`：显示 TCP 连接。
* `-u`：显示 UDP 连接。
* `-l`：仅显示监听状态的连接。
* `-p`：显示与连接关联的进程信息。
* `-a`：显示所有连接，包括监听和非监听状态。
* `-4`：仅显示 IPv4 连接
* `-6`：仅显示 IPv6 连接

**显示进程和端口的关联信息**

```
netstat -ap		#显示每个网络连接的进程 ID（PID）和进程名称，以及相关的本地和远程端口信息。
```

**显示所有网络接口的信息**

```
netstat -i		#列出所有网络接口的信息，包括接口名称、接收和发送的数据包数量、错误等。
netstat -ie		#显示每个网络接口的详细信息，包括硬件地址、IP 地址、广播地址、掩码等。
netstat -ae		#显示每个套接字的详细信息，包括传输队列、接收队列、错误等
```

**显示路由表**

```
netstat -r		#显示系统的路由表，包括目标网络、网关、接口、Flags 等信息。
```

**显示网络统计信息**

```
netstat -s		#显示各种网络统计信息，包括接收和发送的数据包、错误、丢弃的数据包等。
```

**显示套接字状态**

```
netstat -o		#显示系统中所有套接字的详细状态，包括连接状态、套接字类型等。
```

**使用 `watch` 实时监控连接状态**

```
#使用 watch 命令每秒钟更新一次系统中的 ESTABLISHED（已建立）连接，提供实时的连接状态。
watch -n 1 'netstat -an | grep ESTABLISHED'
```

**查看特定进程的网络连接**

```
netstat -tulpan | grep <PID>	#显示特定进程的所有网络连接信息
```

**查看端口的监听进程**

```
fuser -n tcp <port>/udp <port>	#显示特定端口上正在监听的进程
```

**查看打开文件描述符的网络连接**

`lsof`（List Open Files）命令可以列出所有打开的文件描述符，包括网络连接。

```
lsof -i
```

**查看网络性能统计信息**

```
netstat -s | grep -i <keyword>
```

替代 `<keyword>` 为关键词，例如 `retransmitted`、`errors` 等，以查看与网络性能相关的统计信息。

**使用 `tcpdump` 结合 `netstat` 进行深入分析：**

```
tcpdump -i <interface> port <port> -nn -vv -X
```

抓取特定端口的数据包，并使用 `-X` 选项以 ASCII 模式显示负载内容。结合 `netstat` 和 `tcpdump` 可以更深入地分析网络连接。

**nslookup**

`nslookup` 是一个用于查询域名系统 (DNS) 的命令行工具，它允许用户查找域名对应的 IP 地址以及执行其他与 DNS 相关的查询。

```
nslookup example.com	#查询 example.com 的域名解析信息，包括主机名和对应的 IP 地址。
```

**反向解析**

```
nslookup 8.8.8.8	#反向解析，查询 IP 地址 8.8.8.8 对应的主机名
```

**指定 DNS 服务器**

```
nslookup example.com 8.8.4.4	#使用指定的 DNS 服务器（例如，Google 的 DNS 服务器 8.8.4.4）来查询 example.com
```

**查询邮件交换 (MX) 记录**

```
nslookup -query=mx example.com	#查询 example.com 的邮件交换 (MX) 记录，显示邮件服务器的优先级和对应的主机名。
```

**查询其他类型的记录**

```
#查询 example.com 的域名服务器 (NS) 记录。其他可能的记录类型包括 cname（别名）、soa（起始授权机构）、ptr（指针）等。
nslookup -query=ns example.com
```

**关闭递归查询**

```
nslookup -norecurse example.com
```

默认情况下，`nslookup` 会尝试进行递归查询。使用 `-norecurse` 选项可以关闭递归查询，只显示本地 DNS 缓存中的信息。

**设置调试模式**

```
nslookup
set debug
example.com
```

在 `nslookup` 的交互式模式中，使用 `set debug` 可以启用调试模式，显示详细的查询和响应信息。

**使用默认服务器进行查询**

```
nslookup -sil example.com	#-sil 选项表示“使用 Internet 上的默认 DNS 服务器进行查询”。
```

**使用 `awk` 过滤和提取信息**

```
nslookup example.com | awk '/Address/,/Server/'
```

使用 `awk` 过滤 `nslookup` 命令的输出，只显示 IP 地址和服务器信息。

**通过循环批量查询多个域名**

```
for domain in example.com google.com yahoo.com; do nslookup $domain; done
```

通过 `for` 循环批量查询多个域名的解析信息。

**通过 `dig` 命令执行高级 DNS 查询**

```
dig +short example.com
```

`dig` 命令是另一个强大的 DNS 工具，这个示例使用 `+short` 选项只显示紧凑的查询结果。

**tcpdump**

`tcpdump` 是一个用于抓取和分析网络数据包的命令行工具。它在 linux 系统上广泛使用，并提供了强大的网络调试和故障排除功能，非常好用。

**tcpdump [options] [filter_expression]**

* `options`：用于指定 `tcpdump` 的各种选项。
* `filter_expression`：指定过滤要抓取的数据包的表达式。
  * `-i dev` :	选项后面跟着网络接口的名称，用于指定抓取数据包的接口。
  * `host ip` :	host跟着目标主机的 IP 地址，以抓取与该主机相关的数据包。
  * `port n` :	port跟着目标端口号，以抓取在该端口上发送或接收的数据包。
  * `src xxxx dst xxx` :	`src` 和 `dst`跟着源和目标主机的 IP 地址，以抓取在这两个主机之间传输的数据包。
  * `-w filename`： 将抓取的数据包保存到文件中。
  * `-r filename`：从文件中读取数据包并进行分析。
  * `icmp`：抓取 icmp 协议的数据包

**保存或读取数据文件**

```
tcpdump -w output.pcap		#保存抓取的数据包到文件中
tcpdump -r input.pcap		#从文件中读取数据包并进行分析
```

**主机过滤**

```
tcpdump host 192.168.1.1	#抓取指定主机的数据包
tcpdump dst host 192.168.1.2	#抓取所有发往指定主机的数据包
tcpdump src 192.168.1.2 and dst 192.168.1.3	#抓取指定源和目标主机之间的数据包
```

**端口过滤**

```
tcpdump port 80			#抓取所有发往或来自指定端口的数据包
tcpdump dst port 8080		#抓取所有发往指定端口的数据包
tcpdump src port 22		#抓取所有源端口为 22 的数据包
```

**协议类型过滤**

```
tcpdump icmp			#抓取 ICMP 协议的数据包
tcpdump arp			#抓取 ARP 
tcpdump udp			#抓取 udp
tcpdump tcp			#抓取 tcp
```

**数据包大小过滤**

```
tcpdump greater 100		#抓取大于100字节的数据包
tcpdump less 50			#抓取小于50字节的数据包
```

**负载过滤**

```
#抓取包含特定字符串的数据包
tcpdump 'tcp and tcp[13] & 8 != 0'	#抓取所有包含 TCP PSH 标志的数据包
```

**网络接口过滤**

```
tcpdump -i eth0			#抓取指定网络接口上的所有数据包
```

**子网过滤**

```
tcpdump net 192.168.1.0/24	#抓取指定子网中的所有数据包
```

**方向过滤**

```
tcpdump outbound/out host 192.168.1.2	#抓取所有发往目标主机的数据包
tcpdump inbound/in src host 192.168.1.2	#抓取所有由源主机发出的数据包
```

**时间戳过滤**

```
#抓取在指定时间范围内捕获的数据包
tcpdump -tttt -r file.pcap 'after 2023-01-01 12:00:00 and before 2023-01-01 13:00:00'
#上面例子从一个保存的 pcap 文件中抓取在指定时间范围内捕获的数据包。
```

**VLAN 标签过滤**

```
tcpdump vlan 10		#抓取指定 VLAN ID 的数据包
```

**IP 片段过滤**

```
#抓取包含指定 IP 片段的数据包
tcpdump ip[0] & 0xf != 5	#抓取所有 IP 片段偏移不是 5 的 IP 数据包
```

**TTL（Time to Live）过滤**

```
tcpdump ip[8] <= 10		#抓取 TTL 值小于等于 10 的数据包
```

**组合过滤条件**

```
tcpdump dst port 80 and src host 192.168.1.2	#抓取发往指定端口且源主机是特定 IP 的数据包
tcpdump dst port 80 or src host 192.168.1.2	#抓取发往指定端口或源主机是特定 IP 的数据包
```

**应用层协议过滤**

```
#抓取所有 HTTP 请求和响应
tcpdump -A -s 0 'tcp port 80'	#-A 选项用于以ASCII模式显示数据包的负载内容

#抓取所有 DNS 查询和响应
tcpdump -A -s 0 'udp port 53'
```

**按照连接状态过滤**

```
#抓取所有建立的 TCP 连接
tcpdump 'tcp[tcpflags] & (tcp-syn) != 0'	    #抓取所有具有 SYN 标志的 TCP 数据包，即建立连接的数据包。

#抓取所有关闭的 TCP 连接
tcpdump 'tcp[tcpflags] & (tcp-fin|tcp-rst) != 0'    #抓取所有包含 FIN 或 RST 标志的 TCP 数据包，即关闭连接的数据包。
```

**流量分析过滤**

```
#抓取流量最高的前N个主机
tcpdump -nn -c 10 | awk '{print $3}' | sort | uniq -c | sort -nr | head -n 10

#抓取流量最高的前N个端口
tcpdump -nn -c 10 | awk '{print $5}' | cut -d. -f2 | sort | uniq -c | sort -nr | head -n 10
```

**保存捕获的数据包并使用 Wireshark 进行分析**

```
#抓取数据包并保存到文件
tcpdump -w capture.pcap

#使用 Wireshark 打开保存的文件进行分析
wireshark capture.pcap
```

**捕获并将数据包实时传输到远程主机**

```
#将实时捕获的数据包传输到远程主机
tcpdump -w - | ssh user@remote_host 'cat > capture.pcap'
```

**其他：**

ifconfig包含在net-tools中，而net-tools不再维护，此处不再记录ifconfig用法。

## 进程管理

### **基础概念**

* 在Linux中，每个执行的程序（代码）都称为一个进程。每个进程都有一个唯一的进程标识符（PID），并且它们之间可以相互通信。
* 每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。
* 每个进程都可能以两种方式存在。前台和后台。
  * 前台进程：用户目前的屏幕上可以进行操作的。
  * 后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。
* 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。

### **进程的状态**

Linux 进程具有不同的状态，主要有：

* **运行（Running）：** 进程正在运行或者准备运行。
* **等待（Waiting）：** 进程正在等待某个条件的发生，例如等待 I/O 完成。
* **停止（Stopped）：** 进程被暂停，一般由用户发送 `SIGSTOP` 信号。
* **僵尸（Zombie）：** 进程已经终止，但其父进程还没有收到退出状态码。
* **睡眠（Sleeping）：** 进程正在休眠，等待某个事件的发生。

### 进程查看和管理

**服务(Service)**

服务(Service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd 防火墙等),因此我们又称为守护进程。

在 Systemd 管理的现代 Linux 发行版中，服务是由 Systemd 进程来管理的。Systemd 使用配置文件（例如 `.service` 文件）来定义服务的行为和属性。通过 `systemctl` 命令，你可以启动、停止、重启、查看状态等。

在centos6及旧版本系统中，Linux 的启动一直采用[`init`](https://en.wikipedia.org/wiki/Init)进程。

init启动方法有两个缺点：

* 启动时间长。`init`进程是串行启动，只有前一个进程启动完，才会启动下一个进程。
* 启动脚本复杂。`init`进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。

Systemd解决了上面的问题，Systemd 取代了 `initd`，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。Systemd启动服务的方式是并行启动。

**守护进程**

* **后台运行：** 守护进程是在后台运行的进程，通常不与终端交互。这使得它们适用于执行长期运行的任务，而不受用户登录和注销的影响。
* **无用户界面：** 守护进程通常没有用户界面，因为它们不与终端直接交互。它们在后台默默执行任务。
* **长期运行：** 守护进程是设计为在系统启动时启动，并一直运行，等待事件的发生或执行特定的周期性任务。它们通常是系统服务的一部分。
* **独立于用户会话：** 守护进程独立于任何特定用户会话。它们通常不依赖于任何用户登录，而是在系统级别运行。

**启动和终止守护进程**

* **启动守护进程：** 守护进程的启动通常涉及调用 `fork` 系统调用，创建子进程并使其成为独立的守护进程。它可能还涉及将标准输入、标准输出、标准错误重定向到特定的文件或设备，并在后台运行。
* **终止守护进程：** 守护进程的终止通常由系统信号或特定的命令触发。守护进程可以通过捕获和处理信号（例如 `SIGTERM`）来进行优雅的关闭，释放资源，关闭文件描述符等。
* 守护进程通常能够捕获和处理信号。常见的信号包括 `SIGHUP` 用于重新加载配置，`SIGTERM` 用于优雅地终止进程，`SIGKILL` 用于强制终止进程等。

**常见用途和实例**

* **定期任务：** 许多守护进程负责执行定期的任务，例如系统日志守护进程 (`syslogd`) 将系统日志写入文件，或者定期备份守护进程。
* **网络服务：** 守护进程通常用于提供网络服务，如 Web 服务器（`httpd`）、数据库服务（`mysqld`、`postgresql`）等。这些守护进程监听网络端口，接受客户端连接并提供相应的服务。
* **硬件和设备管理：** 一些守护进程可能负责监控和管理硬件设备，例如打印守护进程（`cupsd`）管理打印作业。


**相关命令**

Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。常用命令如下：

**systemctl - 管理系统服务，是 Systemd 的主命令，用于管理系统。**

`systemctl` 是一个用于管理 systemd 系统和服务的工具，用于替代传统的 `init` 系统的一部分。`systemctl` 允许你查看和控制系统服务，包括启动、停止、重启服务等。开机时，`Systemd`只执行 `/etc/systemd/system`目录里面的配置文件。

旧的 `service` 命令仍然可以使用，但实际上它通常是一个指向 `systemctl` 的符号链接

```
systemctl [OPTIONS] COMMAND [UNIT...]
```

* **OPTIONS：** 可选参数，用于调整 `systemctl` 的行为。
* **COMMAND：** 指定要执行的命令，如 `start`、`stop`、`restart`、`status` 等。
* **UNIT：** 指定一个或多个服务单元（Unit），表示要对哪个服务进行操作。服务单元的命名格式通常是 `unit_name.service`。

```
systemctl reboot	# 重启系统
systemctl poweroff	# 关闭系统，切断电源
systemctl halt		# CPU停止工作
systemctl suspend	# 暂停系统
systemctl hibernate	# 让系统进入冬眠状态
systemctl hybrid-sleep	# 让系统进入交互式休眠状态
systemctl rescue	# 启动进入救援状态（单用户状态）
```

**systemd-analyze - 查看启动耗时**

```
systemd-analyze    				# 查看启动耗时                                         
systemd-analyze blame				# 查看每个服务的启动耗时
systemd-analyze critical-chain			# 显示瀑布状的启动过程流
systemd-analyze critical-chain atd.service	# 显示指定服务的启动流
```

**hostnamectl - 查看当前主机的信息**

```
hostnamectl			# 显示当前主机的信息
hostnamectl set-hostname rhel7	# 设置主机名。
```

**localectl - 查看本地化设置**

```
localectl				# 查看本地化设置
localectl set-locale LANG=en_GB.utf8	# 设置本地化参数。
localectl set-keymap en_GB
```

**timedatectl - 查看当前时区设置**

```
timedatect			# 查看当前时区设置
timedatectl list-timezones  	# 显示所有可用的时区                                                  

timedatectl set-timezone America/New_York	# 设置当前时区
timedatectl set-time YYYY-MM-DD
timedatectl set-time HH:MM:SS
```

**loginctl - 查看当前登录的用户**

```
loginctl list-sessions		# 列出当前session
loginctl list-users		# 列出当前登录用户
loginctl show-user ruanyf	# 列出显示指定用户的信息
```

## Systemd Unit

Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。

Unit 一共分成12种。

* Service unit：系统服务
* Target unit：多个 Unit 构成的一个组
* Device Unit：硬件设备
* Mount Unit：文件系统的挂载点
* Automount Unit：自动挂载点
* Path Unit：文件或路径
* Scope Unit：不是由 Systemd 启动的外部进程
* Slice Unit：进程组
* Snapshot Unit：Systemd 快照，可以切回某个快照
* Socket Unit：进程间通信的 socket
* Swap Unit：swap 文件
* Timer Unit：定时器

**systemctl list-units - 查看当前系统的所有 Unit 信息**

```
systemctl list-units					#列出当前系统中所有的Unit（包括服务、套接字、挂载点等）以及它们的状态。
systemctl list-units --all				#列出所有Unit，包括没有找到配置文件的或者启动失败的
systemctl list-units --type=service --state=running	#列出所有正在运行的unit
systemctl list-units --type=service			#显示所有已启用的服务，类型为 service 的 Unit
systemctl list-units --failed				#列出所有加载失败的Unit
```

**systemctl status - 查看系统状态和单个 Unit 的状态**

```
systemctl status					# 显示系统状态
sysystemctl status bluetooth.service			# 显示单个 Unit 的状态
systemctl -H root@rhel7.example.com status atd.service# 显示远程主机的某个 Unit 的状态
```

```
systemctl status httpd

httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)
   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago
 Main PID: 4349 (httpd)
   Status: "Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec"
   CGroup: /system.slice/httpd.service
           ├─4349 /usr/sbin/httpd -DFOREGROUND
           ├─4350 /usr/sbin/httpd -DFOREGROUND
           ├─4351 /usr/sbin/httpd -DFOREGROUND
           ├─4352 /usr/sbin/httpd -DFOREGROUND
           ├─4353 /usr/sbin/httpd -DFOREGROUND
           └─4354 /usr/sbin/httpd -DFOREGROUND

12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...
12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.
12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.
```

* `Loaded`行：配置文件的位置，是否设为开机启动
* `Active`行：表示正在运行
* `Main PID`行：主进程ID
* `Status`行：由应用本身（这里是 httpd ）提供的软件当前状态
* `CGroup`块：应用的所有子进程
* 日志块：应用的日志

除了 `status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。

```
systemctl is-active application.service		# 显示某个 Unit 是否正在运行
systemctl is-failed application.service		# 显示某个 Unit 是否处于启动失败状态
systemctl is-enabled application.service	# 显示某个 Unit 服务是否建立了启动链接
```

**启动和停止 Unit（主要是 service）**

```
#服务启动和关闭，自启
systemctl start service_name	#启动指定的服务
systemctl stop service_name	#停止指定的服务
systemctl restart service_name	#重启指定的服务
systemctl enable service_name	#设置服务开机自启
systemctl disable service_name	#禁用服务开机启动

systemctl show service_name				#显示有关特定服务的详细信息，包括其状态、启动条件等。
systemctl kill apache.service				# 杀死一个服务的所有子进程
systemctl reload apache.service				# 重新加载一个服务的配置文件
systemctl daemon-reload					# 重载所有修改过的配置文件
systemctl show httpd.service				# 显示某个 Unit 的所有底层参数
systemctl show -p CPUShares httpd.service		# 显示某个 Unit 的指定属性的值
systemctl set-property httpd.service CPUShares=500	# 设置某个 Unit 的指定属性
```

**systemctl list-dependencies - 查看和设置系统服务的依赖关系**

Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。

```
systemctl list-dependencies			#显示当前系统中所有服务之间的依赖关系
systemctl list-dependencies --all		#展开 Target, 显示当前系统中所有服务之间的依赖关系
systemctl list-dependencies --all service_name	#显示特定服务及其依赖关系
```

### Unit 的配置文件

每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。

Systemd 默认从目录 `/etc/systemd/system/`读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 `/usr/lib/systemd/system/`，真正的配置文件存放在那个目录。

`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系，设置Unit开机启动。

`systemctl disable`是删除符号链接关系，禁用Unit开机启动。

```
systemctl enable clamd@scan.service
# 等同于
ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service'
```

配置文件的后缀名，就是该 Unit 的种类，比如 `sshd.socket`。如果省略，Systemd 默认后缀名为 `.service`，所以 `sshd`会被理解成 `sshd.service`。

**systemctl list-dependencies-files - 列出所有配置文件**

```
systemctl list-unit-files			# 列出所有配置文件
systemctl list-unit-files --type=service	# 列出指定类型的配置文件
```

示例：

```
systemctl list-unit-files --type=service
UNIT FILE                                  STATE           PRESET  
arp-ethers.service                         disabled        disabled
atd.service                                enabled         enabled 
auditd.service                             enabled         enabled 
autovt@.service                            alias           -   
```

`STATE`：显示每个配置文件的状态，一共有四种

* enabled：已建立启动链接
* disabled：没建立启动链接
* static：该配置文件没有 `[Install]`部分（无法执行），只能作为其他配置文件的依赖
* masked：该配置文件被禁止建立启动链接

**配置文件的格式**

**systemctl cat - 查看配置文件的内容**

配置文件主要放在 `/usr/lib/systemd/system`目录，也可能在 `/etc/systemd/system`目录。也可以在找到配置文件以后，使用文本编辑器打开。

以 `sshd.service`文件为例

```
systemctl cat sshd.service

[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
Type=simple
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
```

* 配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如 `[Unit]`。
* 配置文件的区块名和字段名，都是大小写敏感的。
* 每个区块内部是一些等号连接的键值对，键值对的等号两侧不能有空格。

`[Unit]`区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。

* `Description`：简短描述
* `Documentation`：文档地址
* `Requires`：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败

  * 表示"强依赖"关系，即如果该服务启动失败或异常退出，那么 `sshd.service`也必须退出。
  * 注意，`Wants`字段与 `Requires`字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。
* `Wants`：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败

  * 表示 `sshd.service`与 `sshd-keygen.service`之间存在"弱依赖"关系，即如果"sshd-keygen.service"启动失败或停止运行，不影响 `sshd.service`继续执行。
* `BindsTo`：与 `Requires`类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
* `Before`：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
* `After`：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动

  * 例如：如果 `network.target`或 `sshd-keygen.service`需要启动，那么 `sshd.service`应该在它们之后启动。
* `Conflicts`：这里指定的 Unit 不能与当前 Unit 同时运行
* `Condition...`：当前 Unit 运行必须满足的条件，否则不会运行
* `Assert...`：当前 Unit 运行必须满足的条件，否则会报启动失败

`[Install]`通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。

* `WantedBy`：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 `/etc/systemd/system`目录下面以 Target 名 + `.wants`后缀构成的子目录中
* `RequiredBy`：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 `/etc/systemd/system`目录下面以 Target 名 + `.required`后缀构成的子目录中
* `Alias`：当前 Unit 可用于启动的别名
* `Also`：当前 Unit 激活（enable）时，会被同时激活的其他 Unit

`[Service]`区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。

* `Type`：定义启动时的进程行为。它有以下几种值。
* `Type=simple`：默认值，执行 `ExecStart`指定的命令，启动主进程
* `Type=forking`：以 fork 方式从父进程创建子进程，创建后父进程会立即退出
* `Type=oneshot`：一次性进程，Systemd 会等当前服务退出，再继续往下执行
* `Type=dbus`：当前服务通过D-Bus启动
* `Type=notify`：当前服务启动完毕，会通知 `Systemd`，再继续往下执行
* `Type=idle`：若有其他任务执行完毕，当前服务才会运行
* `ExecStart`：启动当前服务的命令
* `ExecStartPre`：启动当前服务之前执行的命令
* `ExecStartPost`：启动当前服务之后执行的命令
* `ExecReload`：重启当前服务时执行的命令
* `ExecStop`：停止当前服务时执行的命令
* `ExecStopPost`：停止当其服务之后执行的命令
* `RestartSec`：自动重启当前服务间隔的秒数
* `Restart`：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 `always`（总是重启）、`on-success`、`on-failure`、`on-abnormal`、`on-abort`、`on-watchdog`
  * no（默认值）：退出后不会重启
  * on-success：只有正常退出时（退出状态码为0），才会重启
  * on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启
  * on-abnormal：只有被信号终止和超时，才会重启
  * on-abort：只有在收到没有捕捉到的信号终止时，才会重启
  * on-watchdog：超时退出，才会重启
  * always：不管是什么退出原因，总是重启
  * 对于守护进程，推荐设为 `on-failure`。对于那些允许发生错误退出的服务，可以设为 `on-abnormal`。
* `TimeoutSec`：定义 Systemd 停止当前服务之前等待的秒数
* `Environment`：指定环境变量。指定当前服务的环境参数文件。该文件内部的 `key=value`键值对，可以用 `$key`的形式，在当前配置文件中获取。
  * 例如：启动 `sshd`，执行的命令是 `/usr/sbin/sshd -D $OPTIONS`，其中的变量 `$OPTIONS`就来自 `EnvironmentFile`字段指定的环境参数文件。
* `KillMode`：定义 Systemd 如何停止服务。例如：将 `KillMode`设为 `process`，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。
  * control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉
  * process：只杀主进程
  * mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号
  * none：没有进程会被杀掉，只是执行服务的 stop 命令。

示例：

```
[Service]
ExecStart=/bin/echo execstart1
ExecStart=
ExecStart=/bin/echo execstart2
ExecStartPost=/bin/echo post1
ExecStartPost=/bin/echo post2

#输出：上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。
execstart2
post1
post2
```

所有的启动设置之前，都可以加上一个连词号（`-`），表示"抑制错误"，即发生错误的时候，不影响其他命令的执行。比如，`EnvironmentFile=-/etc/sysconfig/sshd`（注意等号后面的那个连词号），就表示即使 `/etc/sysconfig/sshd`文件不存在，也不会抛出错误。

### Target

启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。

简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于"状态点"，启动某个 Target 就好比启动到某种状态。

传统的 `init`启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。

Target 也有自己的配置文件, Target 配置文件里面没有启动命令。

```
systemctl cat multi-user.target

[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
```

* `Requires`字段：要求 `basic.target`一起运行。
* `Conflicts`字段：冲突字段。如果 `rescue.service`或 `rescue.target`正在运行，`multi-user.target`就不能运行，反之亦然。
* `After`：表示 `multi-user.target`在 `basic.target` 、 `rescue.service`、 `rescue.target`之后启动，如果它们有启动的话。
* `AllowIsolate`：允许使用 `systemctl isolate`命令切换到 `multi-user.target`。

**常用命令：**

```
systemctl list-unit-files --type=target		# 查看当前系统的所有 Target
systemctl list-dependencies multi-user.target	# 查看一个 Target 包含的所有 Unit
systemctl get-default				# 查看启动时的默认 Target
systemctl set-default multi-user.target		# 设置启动时的默认 Target

# 切换 Target 时，默认不关闭前一个 Target 启动的进程，
# systemctl isolate 命令改变这种行为，
# 关闭前一个 Target 里面所有不属于后一个 Target 的进程
systemctl isolate multi-user.target
```

Target 与 传统 RunLevel 的对应关系如下：

```
Traditional runlevel      New target name     Symbolically linked to...

Runlevel 0           |    runlevel0.target -> poweroff.target
Runlevel 1           |    runlevel1.target -> rescue.target
Runlevel 2           |    runlevel2.target -> multi-user.target
Runlevel 3           |    runlevel3.target -> multi-user.target
Runlevel 4           |    runlevel4.target -> multi-user.target
Runlevel 5           |    runlevel5.target -> graphical.target
Runlevel 6           |    runlevel6.target -> reboot.target
```

它与 `init`进程的主要差别如下。

* **默认的 RunLevel** （在 `/etc/inittab`文件设置）现在被默认的 Target 取代，位置是 `/etc/systemd/system/default.target`，通常符号链接到 `graphical.target`（图形界面）或者 `multi-user.target`（多用户命令行）。
* **启动脚本的位置** ，以前是 `/etc/init.d`目录，符号链接到不同的 RunLevel 目录 （比如 `/etc/rc3.d`、`/etc/rc5.d`等），现在则存放在 `/lib/systemd/system`和 `/etc/systemd/system`目录。
* **配置文件的位置** ，以前 `init`进程的配置文件是 `/etc/inittab`，各种服务的配置文件存放在 `/etc/sysconfig`目录。现在的配置文件主要存放在 `/lib/systemd`目录，在 `/etc/systemd`目录里面的修改可以覆盖原始设置。

**journalctl - 查看所有日志（内核日志和应用日志）**

Systemd 统一管理所有 Unit 的启动日志，日志的配置文件是 `/etc/systemd/journald.conf` 。

**查看服务的日志**

```
journalctl -u service_name	#显示指定服务的日志，journalctl 命令提供了更灵活的日志查看和过滤功能。


journalctl		# 查看所有日志（默认情况下 ，只保存本次启动的日志）
journalctl -k		# 查看内核日志（不显示应用日志）


journalctl -b		# 查看系统本次启动的日志
journalctl -b -0
journalctl -b -1	# 查看上一次启动的日志（需更改设置）

# 查看指定时间的日志
journalctl --since="2012-10-30 18:17:16"
journalctl --since "20 min ago"
journalctl --since yesterday
journalctl --since "2015-01-10" --until "2015-01-11 03:00"
journalctl --since 09:00 --until "1 hour ago"


journalctl -n		# 显示尾部的最新10行日志
journalctl -n 20	# 显示尾部指定行数的日志
journalctl -f		# 实时滚动显示最新日志


journalctl /usr/lib/systemd/systemd		# 查看指定服务的日志
journalctl _PID=1				# 查看指定进程的日志
journalctl /usr/bin/bash			# 查看某个路径的脚本的日志
journalctl _UID=33 --since today		# 查看指定用户的日志
journalctl -u nginx.service			# 查看某个 Unit 的日志
journalctl -u nginx.service --since today
journalctl -u nginx.service -f			# 实时滚动显示某个 Unit 的最新日志
journalctl -u nginx.service -u php-fpm.service --since today	# 合并显示多个 Unit 的日志

# 查看指定优先级（及其以上级别）的日志，共有8级
# 0: emerg
# 1: alert
# 2: crit
# 3: err
# 4: warning
# 5: notice
# 6: info
# 7: debug
journalctl -p err -b


journalctl --no-pager				# 日志默认分页输出，--no-pager 改为正常的标准输出
journalctl -b -u nginx.service -o json		# 以 JSON 格式（单行）输出
journalctl -b -u nginx.serviceqq -o json-pretty	# 以 JSON 格式（多行）输出，可读性更好


journalctl --disk-usage		# 显示日志占据的硬盘空间
journalctl --vacuum-size=1G	# 指定日志文件占据的最大空间
journalctl --vacuum-time=1years	# 指定日志文件保存多久
```

**top - 实时监控进程**

`top` 是一个实时的系统监视工具，可以用于查看系统的性能状况、运行中的进程以及资源的使用情况。

**`top` 的界面分区：**

* **顶部信息行：** 包括系统当前时间、运行时间、登录用户数、系统负载等信息。
* **进程信息区域：** 列出当前运行的进程，包括进程 ID、用户、CPU 占用、内存占用、进程状态等。
* **底部任务栏：** 显示一些命令快捷键和当前 `top` 的配置信息。

**top界面参数：**

```
top - 15:18:57 up 1 day,  3:30,  2 users,  load average: 0.00, 0.02, 0.00
Tasks: 134 total,   1 running, 133 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7836.2 total,   2418.7 free,   3675.4 used,   1742.1 buff/cache
MiB Swap:   8192.0 total,   8192.0 free,      0.0 used.   3636.1 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
   1882 user      20   0 2717656 141032  61268 S   0.3   1.7   1:05.50 gnome-shell
   2410 user      20   0 1868832  66080  46576 S   0.3   0.8   0:04.65 gnome-terminal-
   3195 user      20   0 1399408  83388  53500 S   0.3   1.1   0:02.19 nautilus
   2353 user      20   0 1323288  42732  36000 S   0.0   0.5   0:01.24 update-notifier
```

**系统信息：**

```
top - 15:18:57 up 1 day,  3:30,  2 users,  load average: 0.00, 0.02, 0.00
```

* `15:18:57`：当前系统时间。
* `up 1 day, 3:30`：系统已经运行了1天3小时30分钟。
* `2 users`：当前有2个用户登录。
* `load average: 0.00, 0.02, 0.00`：系统负载，分别是1分钟、5分钟和15分钟的平均负载。

**任务信息：**

```
Tasks: 134 total,   1 running, 133 sleeping,   0 stopped,   0 zombie
```

* `134 total`：系统中总共有134个任务（进程）。
* `1 running`：有1个进程正在运行。
* `133 sleeping`：有133个进程在休眠。
* `0 stopped`：没有进程被暂停。
* `0 zombie`：没有僵尸进程。

**CPU 使用情况：**

```
%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
```

* `0.0 us`：用户空间 CPU 使用率。
* `0.3 sy`：系统空间 CPU 使用率。
* `0.0 ni`：改变过优先级的进程 CPU 使用率。
* `99.7 id`：空闲 CPU 百分比。
* `0.0 wa`：等待 I/O 的 CPU 使用率。
* `0.0 hi`：硬中断服务的 CPU 使用率。
* `0.0 si`：软中断服务的 CPU 使用率。
* `0.0 st`：被偷走的 CPU 时间百分比。

**内存信息：**

```
MiB Mem :   7836.2 total,   2418.7 free,   3675.4 used,   1742.1 buff/cache
```

* `7836.2 total`：总内存。
* `2418.7 free`：空闲内存。
* `3675.4 used`：已使用内存。
* `1742.1 buff/cache`：缓存和缓冲区占用的内存。

**交换分区信息：**

```
MiB Swap:   8192.0 total,   8192.0 free,      0.0 used.   3636.1 avail Mem
```

* `8192.0 total`：总交换空间。
* `8192.0 free`：空闲交换空间。
* `0.0 used`：已使用的交换空间。
* `3636.1 avail Mem`：当前可用的内存。

**进程列表：**

```
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
1882 user      20   0 2717656 141032  61268 S   0.3   1.7   1:05.50 gnome-shell
...
```

* `PID`：进程 ID。
* `USER`：进程所有者。
* `PR`：进程的调度优先级。
* `NI`：进程的优先级。
* `VIRT`：虚拟内存大小。
* `RES`：实际内存大小。
* `SHR`：共享内存大小。
* `S`：进程状态（R=运行，S=睡眠，Z=僵尸等）。
* `%CPU`：进程占用 CPU 百分比。
* `%MEM`：进程占用内存百分比。
* `TIME+`：进程运行的累计 CPU 时间。
* `COMMAND`：启动进程的命令。

**常用快捷键**

* **`q`：** 退出 `top`。
* **`k`：** 终止一个进程，输入进程的 PID 后按 `Enter`。
* **`Space`：** 更新 `top` 的显示。
* **`1`：** 切换到 CPU 使用情况显示。
* **`m`：** 切换到内存使用情况显示。
* **`M`：** 根据内存占用排序。
* **`P`：** 根据 CPU 占用排序。
* **`f`：** 进入字段管理界面，可以选择要显示的字段。
* **`d`：** 指定刷新间隔时间，默认是 3 秒

**常用命令**

```
top -d 5	#-d seconds： 指定刷新间隔时间，默认是 3 秒
top -p 1234	#-p PID： 指定监视某个特定进程。
top -u username	# u username： 显示指定用户的进程。
```

`top` 默认每隔 3 秒更新一次显示，你可以按 `Space` 键手动刷新，也可以使用 `-d` 选项指定刷新间隔。

**ps - 显示进程信息**

`ps` 命令用于显示系统中当前运行的进程信息。常和grep结合使用

```
ps [options]
```

* **`a`：** 显示所有终端和用户的进程。
* **`u`：** 以用户为主的格式显示进程信息。
* **`x`：** 显示没有终端的进程（通常是守护进程）。
* **`e`：** 显示所有进程，包括其他用户的。
* **`f`：** 显示进程间的父子关系。
* **`l`：** 显示详细格式，包括更多的列。

```
ps aux		#显示所有进程，包括守护进程
ps -ef		#显示所有进程详细信息
ps -u username	#显示指定用户的进程
ps auxf		#显示所有进程的树形结构
ps -p PID	#显示指定进程的详细信息
ps -efl		#使用 l 选项显示详细格式
```

`ps aux` 输出的列信息如下：

```
ps -aux 
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.2  0.7 170916  5540 ?        Ss   Dec08  64:08 /usr/lib/systemd/systemd xx xxx --switched-root --system --deserialize 31
root           2  0.0  0.0      0     0 ?        S    Dec08   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   Dec08   0:00 [rcu_gp]
root           4  0.0  0.0      0     0 ?        I<   Dec08   0:00 [rcu_par_gp]
...
```

* **USER：** 进程所有者，即运行进程的用户名。
* **PID：** 进程标识符，是唯一标识一个进程的数字。
* **%CPU：** 进程使用的 CPU 百分比，即在 CPU 时间中所占的比例。
* **%MEM：** 进程使用的内存百分比，即在物理内存中所占的比例。
* **VSZ：** 进程的虚拟内存大小（以 KB 为单位）。虚拟内存包括进程使用的实际内存和交换空间。
* **RSS：** 进程的实际内存大小（以 KB 为单位）。RSS 表示进程实际使用的物理内存，不包括交换空间。
* **TTY：** 控制终端类型。如果进程与终端关联，将显示终端类型（例如 tty1）。如果没有关联，则显示 `?`。
* **STAT：** 进程状态。常见状态包括：
  * **R（Running）：** 运行中。
  * **S（Sleeping）：** 休眠。
  * **D（Disk sleep）：** 等待磁盘 I/O。
  * **Z（Zombie）：** 僵尸进程。
  * **T（Stopped）：** 已停止。
* **START：** 进程启动的时间。显示进程启动的月份和日期，以及启动的时间。
* **TIME：** 进程已经运行的 CPU 时间。格式为分钟:秒。
* **COMMAND：** 进程的命令及参数。显示进程启动时所使用的命令。

**kill - 终止进程**

`kill` 命令用于终止或发送信号给进程，通过指定 PID 来选择要终止的进程。

```
kill [signal] PID
```

* `signal`：要发送的信号。如果不指定信号，默认是 `TERM`（15号信号，即终止信号）。
* `PID`：要终止的进程的标识符。

**常用信号**

* **`TERM`（15）：** 默认信号，请求进程正常终止。
* **`KILL`（9）：** 强制终止进程，进程将被立即终止。
* **`HUP`（1）：** 重启进程，通常用于重新加载配置文件。
* **`INT`（2）：** 中断进程，相当于按下 `Ctrl+C`。
* **`STOP`（19）：** 暂停进程的执行。
* **`CONT`（18）：** 恢复被暂停的进程。

```
kill PID	#使用默认信号终止进程
kill -TERM PID	#指定信号终止进程
kill -KILL PID	#使用强制终止信号
kill -HUP PID	#重启进程
kill -STOP PID  # 暂停进程
kill -CONT PID  # 恢复进程


kill -TERM -GROUP_PID	#终止进程组
kill -TERM %job_number	#终止后台作业
```

**注意点：**

* 如果没有指定信号，默认是 `TERM`。
* 使用 `kill -KILL` 是一种强制终止的方法，但它可能导致进程没有机会进行清理操作。
* 进程可能会忽略某些信号，具体取决于进程的信号处理程序。

**killall - 终止指定名称的进程**

`killall` 命令用于终止所有具有指定名称的进程。与 `kill` 命令不同，`killall` 不需要指定进程的 PID，而是根据进程的名称来终止匹配的所有进程。

```
killall [options] process_name	#process_name：要终止的进程的名称。
```

* **`-e`：** 显示详细的信息，包括进程的命令行参数。
* **`-i`：** 交互式地询问是否终止进程。
* **`-q`：** 安静模式，不显示任何信息。
* **`-u`：** 指定用户，只终止该用户的进程。

```
killall process_name		#终止指定名称的所有进程
killall -e process_name		#使用 -e 选项显示详细信息
killall -i process_name		#交互式地询问是否终止进程
killall -q process_name		#安静模式，不显示任何信息
killall -u username process_name	#只终止指定用户的进程
```

**注意点：**

* 使用 `killall` 时请小心，确保你不会误伤其他重要的进程。
* 有些系统可能不提供 `killall` 命令，而需要通过安装额外的软件包来获取。

**pgrep - 根据名称查找进程**

`pgrep` 命令用于根据进程的名称查找进程的 PID。与 `killall` 不同，`pgrep` 只返回匹配的进程的 PID，而不会终止它们。

```
pgrep [options] pattern		#pattern：要查找的进程的名称模式。
```

* **`-a`：** 显示匹配进程的完整命令行。
* **`-l`：** 显示匹配进程的 PID 和名称。
* **`-x`：** 只匹配整个进程名称。
* **`-o`：** 显示最早启动的匹配进程的 PID。

```
pgrep process_name		#查找匹配进程的 PID
pgrep -a process_name		#显示匹配进程的完整命令行
pgrep -l process_name		#显示匹配进程的 PID 和名称
pgrep -x process_name		#只匹配整个进程名称
pgrep -o process_name		#显示最早启动的匹配进程的 PID
```

**注意点：**

* `pgrep` 返回的是进程的 PID，而不是进程名称。
* 如果没有匹配的进程，`pgrep` 不会输出任何内容。

**pkill - 根据名称终止进程**

`pkill` 命令用于根据进程的名称终止进程。与 `killall` 类似，`pkill` 不需要指定进程的 PID，而是根据进程的名称来终止匹配的所有进程。

```
pkill [options] pattern		#pattern：要匹配的进程名称模式。
```

* **`-f`：** 匹配整个命令行，而不仅仅是进程名称。
* **`-u`：** 指定用户，只终止该用户的进程。

```
pkill process_name		#终止指定名称的所有进程
pkill -f process_name		#匹配整个命令行并终止进程
pkill -u user1 process_name	#只终止指定用户（例如，user1）的所有进程
```

**注意点：**

* 使用 `pkill` 时请小心，确保你不会误伤其他重要的进程。
* `pkill` 会终止所有匹配的进程，包括与命令行参数匹配的进程。

**nice - 设置进程优先级**

占位

**renice - 修改进程优先级**

占位

**nohup - 在后台运行进程**

`nohup` 是一个在 Unix 和类 Unix 系统上用于运行命令的工具，它允许你在终端退出后仍然能够继续运行该命令。`nohup` 的名称来自"no hang up"的缩写，表明该命令可以在终端挂起（关闭）时继续运行。

```
nohup command [arg]...
```

* `command`：要运行的命令。
* `[arg]...`：命令的参数。

**示例：**

```
nohup command [arg] > output.log 2>&1 &
```

* `>`：将标准输出重定向到指定的文件。
* `2>&1`：将标准错误（2）重定向到与标准输出相同的文件。
* `&`：在后台运行命令。

```
nohup ./my_script.sh > output.log 2>&1 &
```

运行 `./my_script.sh` 脚本，并将标准输出和标准错误重定向到 `output.log` 文件。`&` 符号使命令在后台运行，而 `nohup` 保证了即使终端关闭，该命令也会继续执行。

```
nohup ./my_script.sh > /dev/null 2>&1 &
```

通过将输出重定向到文件，你可以查看命令的输出并调试问题。如果不需要输出，你可以将输出重定向到 `/dev/null`，这样输出就会被丢弃。

**注意点：**

* 使用 `nohup` 启动的命令会忽略 `SIGHUP` 信号，这意味着它们在终端关闭后继续运行。
* 命令在后台运行，可以使用 `jobs` 命令查看后台任务列表。
* 使用 `ps aux | grep command` 可以查看 `nohup` 启动的进程。

**jobs, fg和 bg - 前台作业和后台作业**

`jobs` 命令用于列出当前终端上运行的作业（即后台任务）的状态，每个任务都有一个作业号（job number）。

```
jobs [options]
jobs -l [status]
```

* **`-l`：** 显示详细的信息，包括作业号、状态、进程 ID（PID）和命令。
* **`-p`：** 只显示进程 ID。
* **`-n`：** 只显示最近的作业。
* `status`：作业的状态，例如 `running`、`stopped`。

```
jobs		#列出当前终端上运行的所有后台任务。每个任务都有一个作业号（job number）。
jobs -l		#列出当前终端上运行的所有作业的详细信息，包括作业号、状态、PID 和命令。
jobs -l %1	#根据作业号或标识符查看作业信息


./long_running_task.sh &	#long_running_task.sh 是一个需要很长时间才能完成的命令，使用 & 将其放到后台运行。
jobs -l
#输出可能类似于：
[1]+ 10907 Running                 ./long_running_task.sh &	#10907 是任务的 PID
```

`fg` 命令用于将后台作业切换到前台运行。

```
fg [job_spec]
```

`job_spec`：作业号或作业标识符（可以是 `%1`、`%2` 等）。

```
fg %1		#把作业号为1的作业切换到前台运行。
```

`bg` 命令用于将后台被暂停的任务从后台切换到前台继续运行。

```
bg %1		#将作业号为1被暂停的进程从后台切换到前台继续运行
```

**其他切换任务的方法：**

* **按下 `Ctrl+C` 终止前台任务：**
  在前台运行的任务中，按下 `Ctrl+C` 可以发送中断信号，终止任务。
* **按下 `Ctrl+Z` 暂停前台任务：**
  在前台运行的任务中，按下 `Ctrl+Z` 可以发送暂停信号，将任务置于后台。

## Reference Links:

**#实用指令**

https://github.com/shiguangwl/Linux_Note/tree/main/课程笔记

https://www.runoob.com/linux/linux-command-manual.html

**#crontab定时任务**

https://www.cnblogs.com/ftl1012/p/crontab.html

**#网络配置**

https://tonydeng.github.io/sdn-handbook/linux/config.html

https://www.cnblogs.com/klb561/p/9185532.html

**#systemd入门和实战**

[Systemd 入门教程：命令篇 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)

[Systemd 入门教程：实战篇 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html)

[System and Service Manager (systemd.io)](https://systemd.io/)
