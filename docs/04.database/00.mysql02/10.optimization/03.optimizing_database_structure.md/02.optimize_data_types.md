---
title: 2.优化MySQL数据类型
---
## 针对数值数据进行优化

对于唯一 ID 或可以表示为字符串或数字的其他值，优先选择数字列而不是字符串列。 由于大数值可以用比相应字符串更少的字节来存储，因此传输和比较它们的速度更快并且占用的内存更少。

如果使用数字数据，则在许多情况下从数据库访问信息（使用实时连接）比访问文本文件更快。 数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它涉及的磁盘访问更少。 还可以将代码保存在应用程序中，可以避免解析文本文件来查找行和列边界。

## 针对字符和字符串类型进行优化

对于字符和字符串列，请遵循以下准则：

* 当不需要特定于语言的排序规则功能时，请使用二进制排序规则进行快速比较和排序操作。 可以使用 BINARY 运算符在特定查询中使用二进制排序规则。
* 比较不同列中的值时，请尽可能声明这些列具有相同的字符集和排序规则，以避免运行查询时进行字符串转换。
* 对于大小小于 8KB 的列值，请使用二进制 VARCHAR 而不是 BLOB。 GROUP BY 和 ORDER BY 子句可以生成临时表，如果原始表不包含任何 BLOB 列，这些临时表可以使用 MEMORY 存储引擎。
* 如果表包含名称和地址等字符串列，但许多查询不检索这些列，请考虑将字符串列拆分到单独的表中，并在必要时使用带有外键的联接查询。 当 MySQL 从行中检索任何值时，它会读取包含该行的所有列（可能还有其他相邻行）的数据块。 保持每行较小，仅包含最常用的列，可以让每个数据块容纳更多行。 这种紧凑的表减少了常见查询的磁盘 I/O 和内存使用量。
* 当使用随机生成的值作为 InnoDB 表中的主键时，请在其前面添加一个升序值（例如当前日期和时间）（如果可能）。 当连续的主值在物理上彼此靠近存储时，InnoDB 可以更快地插入和检索它们。

## 针对 BLOB 类型进行优化

当存储包含文本数据的大 blob 时，请考虑首先对其进行压缩。 当整个表被 InnoDB 或 MyISAM 压缩时，不要使用此技术。

* 对于具有多个列的表，为了减少不使用 BLOB 列的查询的内存要求，请考虑将 BLOB 列拆分为单独的表，并在需要时使用联接查询引用它。
* 由于检索和显示 BLOB 值的性能要求可能与其他数据类型有很大不同，因此您可以将 BLOB 特定的表放在不同的存储设备上，甚至放在单独的数据库实例上。 例如，要检索 BLOB 可能需要大量顺序磁盘读取，这比 SSD 设备更适合传统硬盘驱动器。
* 可以将列值的哈希存储在单独的列中，对该列建立索引，然后在查询中测试哈希值，而不是测试非常长的文本字符串是否相等。 （使用 MD5() 或 CRC32() 函数生成哈希值。）由于哈希函数可能会为不同的输入生成重复的结果，因此仍然在查询中包含一个子句 AND blob_column = long_string_value 以防止错误匹配； 性能优势来自于更小的、更容易扫描的哈希值索引。
