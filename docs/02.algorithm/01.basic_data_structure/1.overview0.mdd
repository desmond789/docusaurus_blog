# ä¸‰. åŸºç¡€ç®—æ³•








# å››. é«˜çº§æ•°æ®ç»“æ„ä¸ç®—æ³•è®¾è®¡


## 4.2 Greedy Algorithm

### 1) è´ªå¿ƒä¾‹å­

ç§°ä¹‹ä¸ºè´ªå¿ƒç®—æ³•æˆ–è´ªå©ªç®—æ³•ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯

1. å°†å¯»æ‰¾æœ€ä¼˜è§£çš„é—®é¢˜åˆ†ä¸ºè‹¥å¹²ä¸ªæ­¥éª¤
2. æ¯ä¸€æ­¥éª¤éƒ½é‡‡ç”¨è´ªå¿ƒåŸåˆ™ï¼Œé€‰å–å½“å‰æœ€ä¼˜è§£
3. å› ä¸ºæ²¡æœ‰è€ƒè™‘æ‰€æœ‰å¯èƒ½ï¼Œå±€éƒ¨æœ€ä¼˜çš„å †å **ä¸ä¸€å®š**è®©æœ€ç»ˆè§£æœ€ä¼˜

è´ªå¿ƒç®—æ³•æ˜¯ä¸€ç§åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½é‡‡å–åœ¨å½“å‰çŠ¶æ€ä¸‹æœ€å¥½æˆ–æœ€ä¼˜(å³æœ€æœ‰åˆ©)çš„é€‰æ‹©ï¼Œä»è€Œå¸Œæœ›å¯¼è‡´ç»“æœæ˜¯æœ€å¥½æˆ–æœ€ä¼˜çš„ç®—æ³•ã€‚è¿™ç§ç®—æ³•é€šå¸¸ç”¨äºæ±‚è§£ä¼˜åŒ–é—®é¢˜ï¼Œå¦‚æœ€å°ç”Ÿæˆæ ‘ã€èƒŒåŒ…é—®é¢˜ç­‰ã€‚

è´ªå¿ƒç®—æ³•çš„åº”ç”¨ï¼š

1. èƒŒåŒ…é—®é¢˜ï¼šç»™å®šä¸€ç»„ç‰©å“å’Œä¸€ä¸ªèƒŒåŒ…ï¼Œæ¯ä¸ªç‰©å“æœ‰ä¸€å®šçš„é‡é‡å’Œä»·å€¼ï¼Œè¦æ±‚åœ¨ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡çš„æƒ…å†µä¸‹ï¼Œå°½å¯èƒ½å¤šåœ°è£…å…¥ç‰©å“ã€‚
2. æ´»åŠ¨é€‰æ‹©é—®é¢˜ï¼šåœ¨ä¸€ä¸ªæ´»åŠ¨é›†åˆä¸­ï¼Œæ¯æ¬¡åªèƒ½å‚åŠ ä¸€ä¸ªæ´»åŠ¨ï¼Œé—®å¦‚ä½•å®‰æ’æ—¶é—´ä»¥æœ€å¤§åŒ–æ‰€æœ‰æ´»åŠ¨çš„æ”¶ç›Šã€‚
3. ç¼–è¾‘è·ç¦»é—®é¢˜ï¼šç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å®ƒä»¬ä¹‹é—´çš„æœ€å°ç¼–è¾‘è·ç¦»(å³å°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²æ‰€éœ€çš„æœ€å°‘æ“ä½œæ¬¡æ•°)ã€‚
4. ç½‘ç»œæµé—®é¢˜ï¼šç»™å®šä¸€å¼ æœ‰å‘å›¾å’Œä¸€äº›èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œæ±‚æœ€å¤§æµé‡ã€‚
5. æ‰¾é›¶é—®é¢˜ï¼šç»™å®šä¸€å®šæ•°é‡çš„ç¡¬å¸å’Œéœ€è¦æ‰¾é›¶çš„é‡‘é¢ï¼Œæ±‚ä½¿ç”¨æœ€å°‘çš„ç¡¬å¸æ•°ã€‚

å¸¸è§é—®é¢˜åŠè§£ç­”ï¼š

1. è´ªå¿ƒç®—æ³•ä¸€å®šä¼šæ‰¾åˆ°æœ€ä¼˜è§£å—ï¼Ÿ
   ç­”ï¼šä¸ä¸€å®šã€‚è´ªå¿ƒç®—æ³•åªä¿è¯åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½æ˜¯æœ€ä¼˜çš„ï¼Œä½†å¹¶ä¸èƒ½ä¿è¯æ•´ä¸ªé—®é¢˜çš„æœ€ä¼˜è§£ã€‚ä¾‹å¦‚ï¼ŒèƒŒåŒ…é—®é¢˜ä¸­çš„è´ªå¿ƒç®—æ³•å¯èƒ½ä¼šå¯¼è‡´æœ€åä¸€ä¸ªç‰©å“æ²¡æœ‰è¢«è£…å…¥èƒŒåŒ…ã€‚
2. å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªé—®é¢˜æ˜¯å¦é€‚åˆç”¨è´ªå¿ƒç®—æ³•è§£å†³ï¼Ÿ
   ç­”ï¼šä¸€ä¸ªé—®é¢˜å¦‚æœå¯ä»¥ç”¨é€’å½’çš„æ–¹å¼åˆ†è§£æˆè‹¥å¹²ä¸ªå­é—®é¢˜ï¼Œä¸”æ¯ä¸ªå­é—®é¢˜éƒ½æœ‰æ˜ç¡®çš„æœ€ä¼˜è§£(å³å±€éƒ¨æœ€ä¼˜),é‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±å¯ä»¥ç”¨è´ªå¿ƒç®—æ³•è§£å†³ã€‚
3. è´ªå¿ƒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
   ç­”ï¼šè´ªå¿ƒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å–å†³äºé—®é¢˜çš„è§„æ¨¡å’Œå…·ä½“å®ç°ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¯¹äºè§„æ¨¡è¾ƒå°çš„é—®é¢˜ï¼Œè´ªå¿ƒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ°O(nlogn)æˆ–O(n^2);å¯¹äºè§„æ¨¡è¾ƒå¤§çš„é—®é¢˜ï¼Œå¯èƒ½éœ€è¦O(n^3)æˆ–æ›´é«˜ã€‚

å‡ ä¸ªè´ªå¿ƒçš„ä¾‹å­

#### Dijkstra

```java
// ...
while (!list.isEmpty()) {
    // é€‰å–å½“å‰ã€è·ç¦»æœ€å°ã€‘çš„é¡¶ç‚¹
    Vertex curr = chooseMinDistVertex(list);
    // æ›´æ–°å½“å‰é¡¶ç‚¹é‚»å±…è·ç¦»
    updateNeighboursDist(curr);
    // ç§»é™¤å½“å‰é¡¶ç‚¹
    list.remove(curr);
    // æ ‡è®°å½“å‰é¡¶ç‚¹å·²ç»å¤„ç†è¿‡
    curr.visited = true;
}
```

* æ²¡æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„ä¾‹å­ï¼šè´Ÿè¾¹å­˜åœ¨æ—¶ï¼Œå¯èƒ½å¾—ä¸åˆ°æ­£ç¡®è§£
* é—®é¢˜å‡ºåœ¨è´ªå¿ƒçš„åŸåˆ™ä¼šè®¤ä¸ºæœ¬æ¬¡å·²ç»æ‰¾åˆ°äº†è¯¥é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œä¸‹æ¬¡ä¸ä¼šå†å¤„ç†å®ƒï¼ˆcurr.visited = trueï¼‰
* ä¸ä¹‹å¯¹æ¯”ï¼ŒBellman-Ford å¹¶æ²¡æœ‰è€ƒè™‘å±€éƒ¨è·ç¦»æœ€å°çš„é¡¶ç‚¹ï¼Œè€Œæ˜¯æ¯æ¬¡éƒ½å¤„ç†æ‰€æœ‰è¾¹ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºé”™ï¼Œå½“ç„¶æ•ˆç‡ä¸å¦‚ Dijkstra

#### Prim

```java
// ...
while (!list.isEmpty()) {
    // é€‰å–å½“å‰ã€è·ç¦»æœ€å°ã€‘çš„é¡¶ç‚¹
    Vertex curr = chooseMinDistVertex(list);
    // æ›´æ–°å½“å‰é¡¶ç‚¹é‚»å±…è·ç¦»
    updateNeighboursDist(curr);
    // ç§»é™¤å½“å‰é¡¶ç‚¹
    list.remove(curr);
    // æ ‡è®°å½“å‰é¡¶ç‚¹å·²ç»å¤„ç†è¿‡
    curr.visited = true;
}
```

#### Kruskal

```java
// ...
while (list.size() < size - 1) {
    // é€‰å–å½“å‰ã€è·ç¦»æœ€çŸ­ã€‘çš„è¾¹
    Edge poll = queue.poll();
    // åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦ç›¸äº¤
    int i = set.find(poll.start);
    int j = set.find(poll.end);
    if (i != j) { // æœªç›¸äº¤
        list.add(poll);
        set.union(i, j); // ç›¸äº¤
    }
}
```

å…¶å®ƒè´ªå¿ƒçš„ä¾‹å­

* é€‰æ‹©æ’åºã€å †æ’åº
* æ‹“æ‰‘æ’åº
* å¹¶æŸ¥é›†åˆä¸­çš„ union by size å’Œ union by height
* å“ˆå¤«æ›¼ç¼–ç 
* é’±å¸æ‰¾é›¶ï¼Œè‹±æ–‡æœç´¢å…³é”®å­—

  * change-making problem
  * find Minimum number of Coins
* ä»»åŠ¡ç¼–æ’
* æ±‚å¤æ‚é—®é¢˜çš„è¿‘ä¼¼è§£

### 2) é›¶é’±å…‘æ¢é—®é¢˜

#### æœ‰å‡ ä¸ªè§£ï¼ˆé›¶é’±å…‘æ¢ IIï¼‰Leetcode 518

```java
public class Leetcode518 {
    public int change(int[] coins, int amount) {
        return rec(0, coins, amount, new LinkedList<>(), true);
    }

    /**
     * æ±‚å‡‘æˆå‰©ä½™é‡‘é¢çš„è§£çš„ä¸ªæ•°
     *
     * @param index     å½“å‰ç¡¬å¸ç´¢å¼•
     * @param coins     ç¡¬å¸é¢å€¼æ•°ç»„
     * @param remainder å‰©ä½™é‡‘é¢
     * @param stack     -
     * @param first     -
     * @return è§£çš„ä¸ªæ•°
     */
    public int rec(int index, int[] coins, int remainder, LinkedList<Integer> stack, boolean first) {
        if(!first) {
            stack.push(coins[index]);
        }
        // æƒ…å†µ1ï¼šå‰©ä½™é‡‘é¢ < 0 - æ— è§£
        int count = 0;
        if (remainder < 0) {
            print("æ— è§£ï¼š", stack);
        }
        // æƒ…å†µ2ï¼šå‰©ä½™é‡‘é¢ == 0 - æœ‰è§£
        else if (remainder == 0) {
            print("æœ‰è§£ï¼š", stack);
            count = 1;
        }
        // æƒ…å†µ3ï¼šå‰©ä½™é‡‘é¢ > 0 - ç»§ç»­é€’å½’
        else {
            for (int i = index; i < coins.length; i++) {
                count += rec(i, coins, remainder - coins[i], stack, false);
            }
        }
        if (!stack.isEmpty()) {
            stack.pop();
        }
        return count;
    }

    private static void print(String prompt, LinkedList<Integer> stack) {
        ArrayList<Integer> print = new ArrayList<>();
        ListIterator<Integer> iterator = stack.listIterator(stack.size());
        while (iterator.hasPrevious()) {
            print.add(iterator.previous());
        }
        System.out.println(prompt + print);
    }

    public static void main(String[] args) {
        Leetcode518 leetcode = new Leetcode518();
//        int count = leetcode.coinChange(new int[]{1, 5, 10, 25}, 41);
//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);
//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);
//        int count = leetcode.coinChange(new int[]{1, 2, 5}, 5);
        int count = leetcode.change(new int[]{15, 10, 1}, 21);
        System.out.println(count);
    }

}
```

#### æœ€ä¼˜è§£ï¼ˆé›¶é’±å…‘æ¢ï¼‰- ç©·ä¸¾æ³• Leetcode 322

```java
public class Leetcode322 {
    static int min = -1; // éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°  2 3

    public int coinChange(int[] coins, int amount) {
        rec(0, coins, amount, new AtomicInteger(-1), new LinkedList<>(), true);
        return min;
    }

    // count ä»£è¡¨æŸä¸€ç»„åˆ é’±å¸çš„æ€»æ•°
    public void rec(int index, int[] coins, int remainder, AtomicInteger count, LinkedList<Integer> stack, boolean first) {
        if (!first) {
            stack.push(coins[index]);
        }
        count.incrementAndGet(); // count++
        if (remainder == 0) {
            System.out.println(stack);
            if (min == -1) {
                min = count.get();
            } else {
                min = Integer.min(min, count.get());
            }
        } else if (remainder > 0) {
            for (int i = index; i < coins.length; i++) {
                rec(i, coins, remainder - coins[i], count, stack, false);
            }
        }
        count.decrementAndGet(); // count--
        if (!stack.isEmpty()) {
            stack.pop();
        }
    }

    public static void main(String[] args) {
        Leetcode322 leetcode = new Leetcode322();
//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);
        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);
//        int count = leetcode.coinChange(new int[]{2}, 3);
//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);
        System.out.println(count);
    }
}
```

#### æœ€ä¼˜è§£ï¼ˆé›¶é’±å…‘æ¢ï¼‰- è´ªå¿ƒæ³• Leetcode 322

```java
public class Leetcode322 {
    public int coinChange(int[] coins, int amount) {
        int remainder = amount;
        int count = 0;
        for (int coin : coins) {
            while (remainder - coin > 0) {
                remainder -= coin;
                count++;
            }
            if (remainder - coin == 0) {
                remainder = 0;
                count++;
                break;
            }
        }
        if (remainder > 0) {
            return -1;
        } else {
            return count;
        }
    }

    public static void main(String[] args) {
        Leetcode322 leetcode = new Leetcode322();
        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);
//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);
//        int count = leetcode.coinChange(new int[]{2}, 3);
  
        // é—®é¢˜1 æ²¡æœ‰å›å¤´ï¼Œå¯¼è‡´æ‰¾åˆ°æ›´å·®çš„è§£
//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);  
        // é—®é¢˜2 æ²¡æœ‰å›å¤´ï¼Œå¯¼è‡´æ— è§£
//        int count = leetcode.coinChange(new int[]{15, 10}, 20);  
        System.out.println(count);
    }
}
```

### 3) Huffman ç¼–ç é—®é¢˜

#### é—®é¢˜å¼•å…¥

ä»€ä¹ˆæ˜¯ç¼–ç ï¼Ÿ

ç®€å•è¯´å°±æ˜¯å»ºç«‹ã€å­—ç¬¦ã€‘åˆ°ã€æ•°å­—ã€‘çš„å¯¹åº”å…³ç³»ï¼Œå¦‚ä¸‹é¢å¤§å®¶ç†ŸçŸ¥çš„ ASC II ç¼–ç è¡¨ï¼Œä¾‹å¦‚ï¼Œå¯ä»¥æŸ¥è¡¨å¾—çŸ¥å­—ç¬¦ã€aã€‘å¯¹åº”çš„æ•°å­—æ˜¯åå…­è¿›åˆ¶æ•°ã€0x61ã€‘

| \    | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0a | 0b    | 0c    | 0d    | 0e    | 0f |
| ---- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | ----- | ----- | ----- | ----- | -- |
| 0000 | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0a | 0b    | 0c    | 0d    | 0e    | 0f |
| 0010 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 1a | 1b    | 1c    | 1d    | 1e    | 1f |
| 0020 | 20 | !  | "  | #  | $  | %  | &  | '  | (  | )  | *  | +     | ,     | -     | .     | /  |
| 0030 | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | :  | ;     | `<` | `=` | `>` | ?  |
| 0040 | @  | A  | B  | C  | D  | E  | F  | G  | H  | I  | J  | K     | L     | M     | N     | O  |
| 0050 | P  | Q  | R  | S  | T  | U  | V  | W  | X  | Y  | Z  | [     | \     | ]     | ^     | _  |
| 0060 | `  | a  | b  | c  | d  | e  | f  | g  | h  | i  | j  | k     | l     | m     | n     | o  |
| 0070 | p  | q  | r  | s  | t  | u  | v  | w  | x  | y  | z  | `{` | \|    | `}` | ~     | 7f |

> æ³¨ï¼šä¸€äº›ç›´æ¥ä»¥åå…­è¿›åˆ¶æ•°å­—æ ‡è¯†çš„æ˜¯é‚£äº›ä¸å¯æ‰“å°å­—ç¬¦

ä¼ è¾“æ—¶çš„ç¼–ç 

* java ä¸­æ¯ä¸ª char å¯¹åº”çš„æ•°å­—ä¼šå ç”¨å›ºå®šé•¿åº¦ 2 ä¸ªå­—èŠ‚
* å¦‚æœåœ¨ä¼ è¾“ä¸­ä»é‡‡ç”¨ä¸Šè¿°è§„åˆ™ï¼Œä¼ é€’ abbccccccc è¿™ 10 ä¸ªå­—ç¬¦
  * å®é™…çš„å­—èŠ‚ä¸º  0061006200620063006300630063006300630063ï¼ˆ16è¿›åˆ¶è¡¨ç¤ºï¼‰
  * æ€»å…± 20 ä¸ªå­—èŠ‚ï¼Œä¸ç»æµ

ç°åœ¨å¸Œæœ›æ‰¾åˆ°ä¸€ç§æœ€èŠ‚çœå­—èŠ‚çš„ä¼ è¾“æ–¹å¼ï¼Œæ€ä¹ˆåŠï¼Ÿ

å‡è®¾ä¼ è¾“çš„å­—ç¬¦ä¸­åªåŒ…å« aï¼Œbï¼Œc è¿™ 3 ä¸ªå­—ç¬¦ï¼Œæœ‰åŒå­¦é‡æ–°è®¾è®¡ä¸€å¼ äºŒè¿›åˆ¶ç¼–ç è¡¨ï¼Œè§ä¸‹å›¾

* 0 è¡¨ç¤º a
* 1 è¡¨ç¤º b
* 10 è¡¨ç¤º c

ç°åœ¨è¿˜æ˜¯ä¼ é€’ abbccccccc è¿™ 10 ä¸ªå­—ç¬¦

* å®é™…çš„å­—èŠ‚ä¸º  01110101010101010 ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤ºï¼‰
* æ€»å…±éœ€è¦ 17 bitsï¼Œä¹Ÿå°±æ˜¯ 2 ä¸ªå­—èŠ‚å¤šä¸€ç‚¹ï¼Œè¡Œä¸è¡Œï¼Ÿ

ä¸è¡Œï¼Œå› ä¸ºè§£ç ä¼šå‡ºç°é—®é¢˜ï¼Œå› ä¸º 10 ä¼šè¢«é”™è¯¯çš„è§£ç æˆ baï¼Œè€Œä¸æ˜¯ c

* è§£ç åç»“æœä¸º abbbababababababaï¼Œæ˜¯é”™è¯¯çš„

æ€ä¹ˆè§£å†³ï¼Ÿå¿…é¡»ä¿è¯ç¼–ç åçš„äºŒè¿›åˆ¶æ•°å­—ï¼Œè¦èƒ½åŒºåˆ†å®ƒä»¬çš„å‰ç¼€ï¼ˆprefix-freeï¼‰

ç”¨æ»¡äºŒå‰æ ‘ç»“æ„ç¼–ç ï¼Œå¯ä»¥ç¡®ä¿å‰ç¼€ä¸é‡å¤

![image-20230616094945068](./imgs/image-20230616094945068.png)

* å‘å·¦èµ° 0ï¼Œå‘å³èµ° 1
* èµ°åˆ°å¶å­å­—ç¬¦ï¼Œç´¯è®¡èµ·æ¥çš„ 0 å’Œ 1 å°±æ˜¯è¯¥å­—ç¬¦çš„äºŒè¿›åˆ¶ç¼–ç 

å†æ¥è¯•ä¸€é

* a çš„ç¼–ç  0
* b çš„ç¼–ç  10
* c çš„ç¼–ç  11

ç°åœ¨è¿˜æ˜¯ä¼ é€’ abbccccccc è¿™ 10 ä¸ªå­—ç¬¦

* å®é™…çš„å­—èŠ‚ä¸º  0101011111111111111ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤ºï¼‰
* æ€»å…±éœ€è¦ 19 bitsï¼Œä¹Ÿæ˜¯ 2 ä¸ªå­—èŠ‚å¤šä¸€ç‚¹ï¼Œå¹¶ä¸”è§£ç æ²¡æœ‰é—®é¢˜äº†ï¼Œè¡Œä¸è¡Œï¼Ÿ

è¿™å›è§£ç æ²¡é—®é¢˜äº†ï¼Œä½†å¹¶éæœ€å°‘å­—èŠ‚ï¼Œå› ä¸º c çš„å‡ºç°é¢‘ç‡é«˜ï¼ˆ7 æ¬¡ï¼‰a çš„å‡ºç°é¢‘ç‡ä½ï¼ˆ1 æ¬¡ï¼‰ï¼Œå› æ­¤å‡ºç°é¢‘ç‡é«˜çš„å­—ç¬¦ç¼–ç æˆçŸ­æ•°å­—æ›´ç»æµ

è€ƒå¯Ÿä¸‹é¢çš„æ ‘

![image-20230616095129461](./imgs/image-20230616095129461.png)

* 00 è¡¨ç¤º a
* 01 è¡¨ç¤º b
* 1 è¡¨ç¤º c

ç°åœ¨è¿˜æ˜¯ä¼ é€’ abbccccccc è¿™ 10 ä¸ªå­—ç¬¦

* å®é™…çš„å­—èŠ‚ä¸º 000101 1111111 ï¼ˆäºŒè¿›åˆ¶è¡¨ç¤ºï¼‰
* æ€»å…±éœ€è¦ 13 bitsï¼Œè¿™æ£µæ ‘å°±ç§°ä¹‹ä¸º Huffman æ ‘
* æ ¹æ® Huffman æ ‘å¯¹å­—ç¬¦å’Œæ•°å­—è¿›è¡Œç¼–è§£ç ï¼Œå°±æ˜¯ Huffman ç¼–è§£ç 

#### Huffman æ ‘

```java
public class HuffmanTree {

    /*
        Huffman æ ‘çš„æ„å»ºè¿‡ç¨‹

        1. å°†ç»Ÿè®¡äº†å‡ºç°é¢‘ç‡çš„å­—ç¬¦ï¼Œæ”¾å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—

        2. æ¯æ¬¡å‡ºé˜Ÿä¸¤ä¸ªé¢‘æ¬¡æœ€ä½çš„å…ƒç´ ï¼Œç»™å®ƒä¿©æ‰¾ä¸ªçˆ¹
        3. æŠŠçˆ¹é‡æ–°æ”¾å…¥é˜Ÿåˆ—ï¼Œé‡å¤ 2~3
        4. å½“é˜Ÿåˆ—åªå‰©ä¸€ä¸ªå…ƒç´ æ—¶ï¼ŒHuffman æ ‘æ„å»ºå®Œæˆ
     */

    static class Node {
        Character ch; // å­—ç¬¦
        int freq;     // é¢‘æ¬¡
        Node left;
        Node right;
        String code;  // ç¼–ç 

        public Node(Character ch) {
            this.ch = ch;
        }

        public Node(int freq, Node left, Node right) {
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        int freq() {
            return freq;
        }

        boolean isLeaf() {
            return left == null;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "ch=" + ch +
                    ", freq=" + freq +
                    '}';
        }
    }

    String str;
    Map<Character, Node> map = new HashMap<>();

    public HuffmanTree(String str) {
        this.str = str;
        // åŠŸèƒ½1ï¼šç»Ÿè®¡é¢‘ç‡
        char[] chars = str.toCharArray();
        for (char c : chars) {
            /*if (!map.containsKey(c)) {
                map.put(c, new Node(c));
            }
            Node node = map.get(c);
            node.freq++;*/
            Node node = map.computeIfAbsent(c, Node::new);
            node.freq++;
        }
        // åŠŸèƒ½2: æ„é€ æ ‘
        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(Node::freq));
        queue.addAll(map.values());
        while (queue.size() >= 2) {
            Node x = queue.poll();
            Node y = queue.poll();
            int freq = x.freq + y.freq;
            queue.offer(new Node(freq, x, y));
        }
        Node root = queue.poll();
        // åŠŸèƒ½3ï¼šè®¡ç®—æ¯ä¸ªå­—ç¬¦çš„ç¼–ç , åŠŸèƒ½4ï¼šå­—ç¬¦ä¸²ç¼–ç åå ç”¨ bits
        int sum = dfs(root, new StringBuilder());
        for (Node node : map.values()) {
            System.out.println(node + " " + node.code);
        }
        System.out.println("æ€»å…±ä¼šå ç”¨ bits:" + sum);
    }

    private int dfs(Node node, StringBuilder code) {
        int sum = 0;
        if (node.isLeaf()) {
            node.code = code.toString();
            sum = node.freq * code.length();
        } else {
            sum += dfs(node.left, code.append("0"));
            sum += dfs(node.right, code.append("1"));
        }
        if (code.length() > 0) {
            code.deleteCharAt(code.length() - 1);
        }
        return sum;
    }

    public static void main(String[] args) {
        new HuffmanTree("abbccccccc");
    }
}
```

> ***æ³¨æ„***
>
> * Node::new æ˜¯ä¸€ä¸ª Functionï¼Œæ ¹æ® keyï¼ˆå³å­—ç¬¦ï¼‰ç”Ÿæˆ Node å¯¹è±¡
> * å¯¹åº”çš„æ˜¯ public Node(Character ch) æœ‰å‚æ„é€ 

#### Huffman ç¼–è§£ç 

è¡¥å……ä¸¤ä¸ªæ–¹æ³•ï¼Œæ³¨æ„ä¸ºäº†ç®€å•æœŸé—´ç”¨äº†ç¼–è§£ç éƒ½ç”¨å­—ç¬¦ä¸²æ¼”ç¤ºï¼Œå®é™…åº”è¯¥æŒ‰ bits ç¼–è§£ç 

```java
public class HuffmanTree {
    // ...
  
    // ç¼–ç 
    public String encode() {
        char[] chars = str.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (char c : chars) {
            sb.append(map.get(c).code);
        }
        return sb.toString();
    }

    // è§£ç 
    public String decode(String str) {
        /*
            ä»æ ¹èŠ‚ç‚¹ï¼Œå¯»æ‰¾æ•°å­—å¯¹åº”çš„å­—ç¬¦
                æ•°å­—æ˜¯ 0 å‘å·¦èµ°
                æ•°å­—æ˜¯ 1 å‘å³èµ°
                å¦‚æœæ²¡èµ°åˆ°å¤´ï¼Œæ¯èµ°ä¸€æ­¥æ•°å­—çš„ç´¢å¼• i++
            èµ°åˆ°å¤´å°±å¯ä»¥æ‰¾åˆ°è§£ç å­—ç¬¦ï¼Œå†å°† node é‡ç½®ä¸ºæ ¹èŠ‚ç‚¹
         */
        char[] chars = str.toCharArray();
        int i = 0;
        StringBuilder sb = new StringBuilder();
        Node node = root;
        while (i < chars.length) {
            if (!node.isLeaf()) { // éå¶å­
                if(chars[i] == '0') { // å‘å·¦èµ°
                    node = node.left;
                } else if(chars[i] == '1') { // å‘å³èµ°
                    node = node.right;
                }
                i++;
            }
            if (node.isLeaf()) {
                sb.append(node.ch);
                node = root;
            }
        }
        return sb.toString();
    }
  
    @SuppressWarnings("all")
    public static void main(String[] args) {
        HuffmanTree tree = new HuffmanTree("abbccccccc");
        String encoded = tree.encode();
        System.out.println(encoded);
        System.out.println(tree.decode(encoded));
    }
}
```

> ***æ³¨æ„***
>
> * å¾ªç¯ä¸­éå¶å­èŠ‚ç‚¹ i è¦è‡ªå¢ï¼Œä½†å¶å­èŠ‚ç‚¹ i æš‚ä¸è‡ªå¢
> * ç¬¬ä¸€ä¸ªéå¶å­çš„ if åˆ¤æ–­ç»“æŸåï¼Œä»éœ€è¦ç¬¬äºŒä¸ªå¶å­çš„ if åˆ¤æ–­ï¼Œå› ä¸ºåœ¨ç¬¬ä¸€ä¸ª if å†… node å‘ç”Ÿäº†å˜åŒ–

#### ç›¸å…³é¢˜ç›®

| é¢˜ç›®ç¼–å·          | é¢˜ç›®æ ‡é¢˜           | ç®—æ³•æ€è·¯         |
| ----------------- | ------------------ | ---------------- |
| 1167ï¼ˆPlus é¢˜ç›®ï¼‰ | è¿æ¥æ£’æçš„æœ€ä½è´¹ç”¨ | Huffman æ ‘ã€è´ªå¿ƒ |

å‚è€ƒè§£ç­”

```java
/**
 * <h3>è¿æ¥æ£’æçš„æœ€ä½è´¹ç”¨</h3>
 * <p>ä¸ºäº†è£…ä¿®æ–°æˆ¿ï¼Œä½ éœ€è¦åŠ å·¥ä¸€äº›é•¿åº¦ä¸ºæ­£æ•´æ•°çš„æ£’æã€‚å¦‚æœè¦å°†é•¿åº¦åˆ†åˆ«ä¸º X å’Œ Y çš„ä¸¤æ ¹æ£’æè¿æ¥åœ¨ä¸€èµ·ï¼Œä½ éœ€è¦æ”¯ä»˜ X + Y çš„è´¹ç”¨ã€‚ è¿”å›è®²æ‰€æœ‰æ£’æè¿æˆä¸€æ ¹æ‰€éœ€è¦çš„æœ€ä½è´¹ç”¨ã€‚</p>
 */
public class Leetcode1167 {
    /*
        ä¸¾ä¾‹ æ£’æä¸º [1,8,3,5]

        å¦‚æœä»¥å¦‚ä¸‹é¡ºåºè¿æ¥(éæœ€ä¼˜)
        - 1+8=9
        - 9+3=12
        - 12+5=17
        æ€»è´¹ç”¨ä¸º 9+12+17=38

        å¦‚æœä»¥å¦‚ä¸‹é¡ºåºè¿æ¥(æœ€ä¼˜)
        - 1+3=4
        - 4+5=9
        - 8+9=17
        æ€»è´¹ç”¨ä¸º 4+9+17=30
     */
    int connectSticks(int[] sticks) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for (int stick : sticks) {
            queue.offer(stick);
        }

        int sum = 0;
        while (queue.size() >= 2) {
            Integer x = queue.poll();
            Integer y = queue.poll();
            int c = x + y;
            sum += c;
            queue.offer(c);
        }
        return sum;
    }

    public static void main(String[] args) {
        Leetcode1167 leetcode = new Leetcode1167();
        System.out.println(leetcode.connectSticks(new int[]{1, 8, 3, 5})); // 30
        System.out.println(leetcode.connectSticks(new int[]{2, 4, 3})); // 14
    }
}
```

### 4) æ´»åŠ¨é€‰æ‹©é—®é¢˜

```java
public class ActivitySelectionProblem {

    /*
        è¦åœ¨ä¸€ä¸ªä¼šè®®å®¤ä¸¾åŠ n ä¸ªæ´»åŠ¨
        - æ¯ä¸ªæ´»åŠ¨æœ‰å®ƒä»¬å„è‡ªçš„èµ·å§‹å’Œç»“æŸæ—¶é—´
        - æ‰¾å‡ºåœ¨æ—¶é—´ä¸Šäº’ä¸å†²çªçš„æ´»åŠ¨ç»„åˆï¼Œèƒ½å¤Ÿæœ€å……åˆ†åˆ©ç”¨ä¼šè®®å®¤ï¼ˆä¸¾åŠçš„æ´»åŠ¨æ¬¡æ•°æœ€å¤šï¼‰

        ä¾‹1
            0   1   2   3   4   5   6   7   8   9
                |-------)
                    |-------)
                        |-------)
        ä¾‹2
            0   1   2   3   4   5   6   7   8   9
                |---)
                        |---)
            |-----------------------)
                                |-------)
                                            |---)
                                |---------------)





        å‡ ç§è´ªå¿ƒç­–ç•¥
        1. ä¼˜å…ˆé€‰æ‹©æŒç»­æ—¶é—´æœ€çŸ­çš„æ´»åŠ¨
            0   1   2   3   4   5   6   7   8   9
                |---------------)
                            |-------)
                                |---------------)

        2. ä¼˜å…ˆé€‰æ‹©å†²çªæœ€å°‘çš„æ´»åŠ¨
            0   1   2   3   4   5   6   7   8   9
            |-------)                                       3
                |-------)                                   4
                |-------)                                   4
                |-------)                                   4
                    |-------)                               4
                        |-------)                           2
                            |-----------)                   4
                                    |-------)               4
                                    |-------)               4
                                    |-------)               4
                                        |-------)           3

        3. ä¼˜å…ˆé€‰æ‹©æœ€å…ˆå¼€å§‹çš„æ´»åŠ¨
            0   1   2   3   4   5   6   7   8   9
            |-----------------------------------)
                |---)
                    |---)
                        |---)

        4. ä¼˜å…ˆé€‰æ‹©æœ€åç»“æŸçš„æ´»åŠ¨
     */

    static class Activity {
        int index;
        int start;
        int finish;

        public Activity(int index, int start, int finish) {
            this.index = index;
            this.start = start;
            this.finish = finish;
        }

        @Override
        public String toString() {
            return "Activity(" + index + ")";
        }
    }

    public static void main(String[] args) {
        Activity[] activities = new Activity[]{
                new Activity(0, 1, 3),
                new Activity(1, 2, 4),
                new Activity(2, 3, 5)
        };
//        Activity[] activities = new Activity[]{
//                new Activity(0, 1, 2),
//                new Activity(1, 3, 4),
//                new Activity(2, 0, 6),
//                new Activity(3, 5, 7),
//                new Activity(4, 8, 9),
//                new Activity(5, 5, 9)
//        };
        select(activities, activities.length);
    }

    public static void select(Activity[] activities, int n) {
        List<Activity> result = new ArrayList<>();
        int i, j;
        i = 0;
        result.add(activities[i]);
        for (j = 1; j < n; j++) {
            if (activities[j].start >= activities[i].finish) {
                result.add(activities[j]);
                i = j;
            }
        }
        System.out.println(result);
    }
}
```

#### æ— é‡å åŒºé—´-Leetcode 435

| é¢˜ç›®ç¼–å· | é¢˜ç›®æ ‡é¢˜   | ç®—æ³•æ€è·¯ |
| -------- | ---------- | -------- |
| 435      | æ— é‡å åŒºé—´ | è´ªå¿ƒ     |

å‚è€ƒè§£ç­”

```java
// ä¸‹é¢ä»£ç ä¸º Leetcode 435 é¢˜è§£
public int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));
    int i, j;
    i = 0;
    int count = 1;
    for (j = 1; j < intervals.length; j++) {
        if (intervals[j][0] >= intervals[i][1]) {
            i = j;
            count++;
        }
    }
    return intervals.length - count;
}
```

* æ‰¾åˆ°ä¸é‡å çš„æœ€å¤šçš„æ´»åŠ¨æ•°ï¼ˆcountï¼‰ï¼Œå³æ´»åŠ¨é€‰æ‹©é—®é¢˜åŸå§‹éœ€æ±‚
* åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ´»åŠ¨æ€»æ•° - countï¼Œå°±æ˜¯é¢˜ç›®è¦çš„æ’é™¤æ•°é‡

### 5) åˆ†æ•°èƒŒåŒ…é—®é¢˜

#### è´ªå¿ƒæ³•

```java
public class FractionalKnapsackProblem {

    /*
    1. nä¸ªç‰©å“éƒ½æ˜¯æ¶²ä½“ï¼Œæœ‰é‡é‡å’Œä»·å€¼
    2. ç°åœ¨ä½ è¦å–èµ° 10å‡ çš„æ¶²ä½“
    3. æ¯æ¬¡å¯ä»¥ä¸æ‹¿ï¼Œå…¨æ‹¿ï¼Œæˆ–æ‹¿ä¸€éƒ¨åˆ†ï¼Œé—®æœ€é«˜ä»·å€¼æ˜¯å¤šå°‘

        ç¼–å· é‡é‡(å‡) ä»·å€¼
        0   4       24      æ°´
        1   8       160     ç‰›å¥¶       é€‰ä¸­ 7/8
        2   2       4000    äº”ç²®æ¶²     é€‰ä¸­
        3   6       108     å¯ä¹
        4   1       4000    èŒ…å°       é€‰ä¸­

        8140

        ç®€åŒ–èµ·è§ï¼Œç»™å‡ºçš„æ•°æ®éƒ½æ˜¯ã€ä»·å€¼/é‡é‡ã€‘èƒ½å¤Ÿæ•´é™¤ï¼Œé¿å…è®¡ç®—ç»“æœä¸­å‡ºç°å°æ•°ï¼Œå¢åŠ å¿ƒç®—éš¾åº¦
     */

    static class Item {
        int index;
        int weight;
        int value;

        public Item(int index, int weight, int value) {
            this.index = index;
            this.weight = weight;
            this.value = value;
        }

        int unitPrice() {
            return value / weight;
        }

        @Override
        public String toString() {
            return "Item(" + index + ")";
        }
    }

    public static void main(String[] args) {
        Item[] items = new Item[]{
                new Item(0, 4, 24),
                new Item(1, 8, 160),
                new Item(2, 2, 4000),
                new Item(3, 6, 108),
                new Item(4, 1, 4000),
        };
        select(items, 10);
    }

    static void select(Item[] items, int total) {
        Arrays.sort(items, Comparator.comparingInt(Item::unitPrice).reversed());
        int remainder = total;
        int max = 0;
        for (Item item : items) {
            if (remainder - item.weight > 0) {
                max += item.value;
                remainder -= item.weight;
            } else {
                max += remainder * item.unitPrice();
                break;
            }
        }
        System.out.println("æœ€é«˜ä»·å€¼ä¸ºï¼š" + max);
    }


}
```

### 6) 0-1 èƒŒåŒ…é—®é¢˜

#### è´ªå¿ƒæ³•

å¯èƒ½å¾—ä¸åˆ°æœ€ä¼˜è§£

```java
public class KnapsackProblem {
    /*
    1. nä¸ªç‰©å“éƒ½æ˜¯å›ºä½“ï¼Œæœ‰é‡é‡å’Œä»·å€¼
    2. ç°åœ¨ä½ è¦å–èµ°ä¸è¶…è¿‡ 10å…‹ çš„ç‰©å“
    3. æ¯æ¬¡å¯ä»¥ä¸æ‹¿æˆ–å…¨æ‹¿ï¼Œé—®æœ€é«˜ä»·å€¼æ˜¯å¤šå°‘

        ç¼–å· é‡é‡(g)  ä»·å€¼(å…ƒ)
        0   1       1_000_000      é’»æˆ’ä¸€æš
        1   4       1600           é»„é‡‘ä¸€å—
        2   8       2400           çº¢å®çŸ³æˆ’æŒ‡ä¸€æš
        3   5       30             ç™½é“¶ä¸€å—

     */

    static class Item {
        int index;
        int weight;
        int value;

        public Item(int index, int weight, int value) {
            this.index = index;
            this.weight = weight;
            this.value = value;
        }

        public int unitValue() {
            return value / weight;
        }

        @Override
        public String toString() {
            return "Item(" + index + ")";
        }
    }

    public static void main(String[] args) {
        Item[] items = new Item[]{
                new Item(0, 1, 1_000_000),
                new Item(1, 4, 1600),
                new Item(2, 8, 2400),
                new Item(3, 5, 30)
        };
        select(items, 10);
    }

    static void select(Item[] items, int total) {
        Arrays.sort(items, Comparator.comparingInt(Item::unitValue).reversed());
        int max = 0; // æœ€å¤§ä»·å€¼
        for (Item item : items) {
            System.out.println(item);
            if (total >= item.weight) { // å¯ä»¥æ‹¿å®Œ
                total -= item.weight;
                max += item.value;
            } else { // æ‹¿ä¸å®Œ
//                max += total * item.unitValue();
//                break;
            }
        }
        System.out.println("æœ€å¤§ä»·å€¼æ˜¯:" + max);
    }
}
```

### è´ªå¿ƒç®—æ³•çš„å±€é™

| é—®é¢˜åç§°             | æ˜¯å¦èƒ½ç”¨è´ªå¿ƒå¾—åˆ°æœ€ä¼˜è§£ | æ›¿æ¢è§£æ³•     |
| -------------------- | ---------------------- | ------------ |
| Dijkstra(ä¸å­˜åœ¨è´Ÿè¾¹) | âœ”ï¸                   |              |
| Dijkstra(å­˜åœ¨è´Ÿè¾¹)   | âŒ                     | Bellman-Ford |
| Prim                 | âœ”ï¸                   |              |
| Kruskal              | âœ”ï¸                   |              |
| é›¶é’±å…‘æ¢             | âŒ                     | åŠ¨æ€è§„åˆ’     |
| Huffman æ ‘           | âœ”ï¸                   |              |
| æ´»åŠ¨é€‰æ‹©é—®é¢˜         | âœ”ï¸                   |              |
| åˆ†æ•°èƒŒåŒ…é—®é¢˜         | âœ”ï¸                   |              |
| 0-1 èƒŒåŒ…é—®é¢˜         | âŒ                     | åŠ¨æ€è§„åˆ’     |

### 7) Set cover problem

é›†åˆè¦†ç›–é—®é¢˜

## 4.3 Dynamic-Programming

### 1) Fibonacci

```java
public class Fibonacci {
    public static void main(String[] args) {
        System.out.println(fibonacci(13));
    }

    public static int fibonacci(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        if (n < 2) {
            return dp[n];
        }
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
}
```

#### é™ç»´

```java
public class Fibonacci {
    public static void main(String[] args) {
        System.out.println(fibonacci(13));
    }

    public static int fibonacci(int n) {  
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int a = 0;
        int b = 1;
        for (int i = 2; i <= n; i++) {
            int c = b + a;
            a = b;
            b = c;
        }
        return b;
    }
}
```

### 2) æœ€çŸ­è·¯å¾„ - Bellman-Ford

```java
public class BellmanFord {
    static class Edge {
        int from;
        int to;
        int weight;

        public Edge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }

    /*
            f(v) ç”¨æ¥è¡¨ç¤ºä»èµ·ç‚¹å‡ºå‘ï¼Œåˆ°è¾¾ v è¿™ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·ç¦»
            åˆå§‹æ—¶
            f(v) = 0   å½“ v==èµ·ç‚¹ æ—¶
            f(v) = âˆ   å½“ v!=èµ·ç‚¹ æ—¶

            ä¹‹å
            æ–°           æ—§     æ‰€æœ‰from
            f(to) = min(f(to), f(from) + from.weight)

            from ä»å“ªæ¥
            to   åˆ°å“ªå»

            f(v4) = min( âˆ, f(v3) + 11 ) = 20
            f(v4) = min( 20, f(v2) + 15 ) = 20


            v1  v2  v3  v4  v5  v6
            0   âˆ   âˆ   âˆ   âˆ   âˆ
            0   7   9   âˆ   âˆ   14  ç¬¬ä¸€è½®
            0   7   9   20  23  11  ç¬¬äºŒè½®
            0   7   9   20  20  11  ç¬¬ä¸‰è½®
            0   7   9   20  20  11  ç¬¬å››è½®
            0   7   9   20  20  11  ç¬¬äº”è½®

     */

    public static void main(String[] args) {
        List<Edge> edges = List.of(
                new Edge(6, 5, 9),
                new Edge(4, 5, 6),
                new Edge(1, 6, 14),
                new Edge(3, 6, 2),
                new Edge(3, 4, 11),
                new Edge(2, 4, 15),
                new Edge(1, 3, 9),
                new Edge(1, 2, 7)
        );
        int[] dp = new int[7]; // ä¸€ç»´æ•°ç»„ç”¨æ¥ç¼“å­˜ç»“æœ
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        print(dp);
        for (int i = 0; i < 5; i++) {
            for (Edge e : edges) {
                if(dp[e.from] != Integer.MAX_VALUE) {
                    dp[e.to] = Integer.min(dp[e.to], dp[e.from] + e.weight);
                }
            }
        }
        print(dp);
    }

    static void print(int[] dp) {
        System.out.println(Arrays.stream(dp)
                .mapToObj(i -> i == Integer.MAX_VALUE ? "âˆ" : String.valueOf(i))
                .collect(Collectors.joining(",", "[", "]")));
    }
}
```

### 3) ä¸åŒè·¯å¾„-Leetcode 62

æœºå™¨äººè¦ä»å·¦ä¸Šè§’èµ°åˆ°å³ä¸‹è§’ï¼Œæ¯æ¬¡åªèƒ½**å‘å³**æˆ–**å‘ä¸‹**ï¼Œé—®ä¸€å…±æœ‰å¤šå°‘æ¡ä¸åŒè·¯å¾„ï¼Ÿ

![](./imgs/robot_maze2.png)

åˆ†æï¼Œå…ˆè€ƒè™‘è¾ƒä¸ºç®€å•çš„æƒ…å†µ

![](./imgs/robot_maze.png)

å¯èƒ½è·¯å¾„æœ‰ä¸‰ç§æƒ…å†µï¼š

* ğŸ‘‰ ğŸ‘‡ ğŸ‘‡
* ğŸ‘‡ ğŸ‘‡ğŸ‘‰
* ğŸ‘‡ğŸ‘‰ğŸ‘‡

åˆ†æï¼šè®¾åæ ‡ä¸ºï¼Œå…±æœ‰ m è¡Œ n åˆ—

```
(0,0)	(0,1)
(1,0)	(1,1)
(2,0)	(2,1)
```

å¦‚æœç»ˆç‚¹æ˜¯ (0,1) é‚£ä¹ˆåªæœ‰ä¸€ç§èµ°æ³•

å¦‚æœç»ˆç‚¹æ˜¯ (1,0) é‚£ä¹ˆä¹Ÿåªæœ‰ä¸€ç§èµ°æ³•

å¦‚æœç»ˆç‚¹æ˜¯ (1,1) å‘¢ï¼Œå®ƒçš„èµ°æ³•æ˜¯ä»å®ƒçš„ä¸Šæ–¹èµ°ä¸‹æ¥ï¼Œæˆ–è€…ä»å®ƒçš„å·¦è¾¹èµ°è¿‡æ¥ï¼Œå› æ­¤èµ°æ³• = (0,1) + (1,0) = 2ç§

å¦‚æœç»ˆç‚¹æ˜¯ (2,0) é‚£ä¹ˆä¹Ÿåªæœ‰ä¸€ç§èµ°æ³•

å¦‚æœç»ˆç‚¹æ˜¯ (2,1) å‘¢ï¼Œå®ƒçš„èµ°æ³•æ˜¯ä»å®ƒçš„ä¸Šæ–¹èµ°ä¸‹æ¥ï¼Œæˆ–è€…ä»å®ƒçš„å·¦è¾¹èµ°è¿‡æ¥ï¼Œå› æ­¤èµ°æ³• = (1,1) + (2,0) = 3ç§

æ€»ç»“è§„å¾‹å‘ç°ï¼š

1. ç»ˆç‚¹æ˜¯ (0,1) (0,2) (0,3) ... (0,n) èµ°æ³•åªæœ‰1ç§
2. ç»ˆç‚¹æ˜¯ (1,0) (2,0) (3,0) ... (m,0) èµ°æ³•ä¹Ÿåªæœ‰1ç§
3. é™¤äº†ä¸Šé¢ä¸¤ç§æƒ…å†µä»¥å¤–ï¼Œ(i,j) å¤„çš„èµ°æ³•ç­‰äº(i-1,j) + (i,j-1) çš„èµ°æ³•ä¹‹å’Œï¼Œå³ä¸ºé€’æ¨å…¬å¼

ç”»è¡¨æ ¼

```
0	1	1	1	1	1	1
1	2	3	4	5	6	7
1	3	6	10	15	21	28
```

é¢˜è§£

```java
public class UniquePaths {
    public static void main(String[] args) {
        int count = new UniquePaths().uniquePaths(3, 7);
        System.out.println(count);
    }

    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

#### é™ç»´

```java
public class UniquePaths {
    public static void main(String[] args) {
        int count = new UniquePaths().uniquePaths(3, 7);
        System.out.println(count);
    }

    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < m; i++) {
            dp[0] = 1;
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
```

ç±»ä¼¼äºä¸è§„åˆ™çš„æ¨è¾‰ä¸‰è§’

### 4) 0-1 èƒŒåŒ…é—®é¢˜

```java
public class KnapsackProblem {
    /*
        1. nä¸ªç‰©å“éƒ½æ˜¯å›ºä½“ï¼Œæœ‰é‡é‡å’Œä»·å€¼
        2. ç°åœ¨ä½ è¦å–èµ°ä¸è¶…è¿‡ 10å…‹ çš„ç‰©å“
        3. æ¯æ¬¡å¯ä»¥ä¸æ‹¿æˆ–å…¨æ‹¿ï¼Œé—®æœ€é«˜ä»·å€¼æ˜¯å¤šå°‘

            ç¼–å· é‡é‡(g)  ä»·å€¼(å…ƒ)                        ç®€ç§°
            1   4       1600           é»„é‡‘ä¸€å—   400    A
            2   8       2400           çº¢å®çŸ³ä¸€ç²’ 300    R
            3   5       30             ç™½é“¶ä¸€å—         S
            0   1       1_000_000      é’»çŸ³ä¸€ç²’          D
        1_001_630

        1_002_400
     */

    /*
        1   2   3   4   5   6   7   8   9   10
                    a
                    a               r
                    a               r
        d               da          da  dr  dr
     */

    static class Item {
        int index;
        String name;
        int weight;
        int value;

        public Item(int index, String name, int weight, int value) {
            this.index = index;
            this.name = name;
            this.weight = weight;
            this.value = value;
        }

        @Override
        public String toString() {
            return "Item(" + name + ")";
        }
    }

    public static void main(String[] args) {
        Item[] items = new Item[]{
                new Item(1, "é»„é‡‘", 4, 1600),
                new Item(2, "å®çŸ³", 8, 2400),
                new Item(3, "ç™½é“¶", 5, 30),
                new Item(4, "é’»çŸ³", 1, 10_000),
        };
        System.out.println(select(items, 10));
    }

    static int select(Item[] items, int total) {
        int[][] dp = new int[items.length][total + 1];
        print(dp);
        Item item0 = items[0];
        for (int j = 0; j < total + 1; j++) {
            if (j >= item0.weight) {
                dp[0][j] = item0.value;
            }
        }
        print(dp);
        for (int i = 1; i < dp.length; i++) {
            Item item = items[i];
            for (int j = 1; j < total + 1; j++) {
                // x: ä¸Šä¸€æ¬¡åŒå®¹é‡èƒŒåŒ…çš„æœ€å¤§ä»·å€¼
                int x = dp[i - 1][j];
                if (j >= item.weight) {
                    // j-item.weight: å½“å‰èƒŒåŒ…å®¹é‡-è¿™æ¬¡ç‰©å“é‡é‡=å‰©ä½™èƒŒåŒ…ç©ºé—´
                    // y: å‰©ä½™èƒŒåŒ…ç©ºé—´èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼ + è¿™æ¬¡ç‰©å“ä»·å€¼
                    int y = dp[i - 1][j - item.weight] + item.value;
                    dp[i][j] = Integer.max(x, y);
                } else {
                    dp[i][j] = x;
                }
            }
            print(dp);
        }
        return dp[dp.length - 1][total];
    }

    static void print(int[][] dp) {
        System.out.println("   " + "-".repeat(63));
        Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray();
        System.out.printf(("%5d ".repeat(dp[0].length)) + "%n", array);
        for (int[] d : dp) {
            array = Arrays.stream(d).boxed().toArray();
            System.out.printf(("%5d ".repeat(d.length)) + "%n", array);
        }
    }
}
```

#### é™ç»´

```java
static int select(Item[] items, int total) {
    int[] dp = new int[total + 1];
    for (Item item : items) {
        for (int j = total; j > 0; j--) {
            if (j >= item.weight) { // è£…å¾—ä¸‹
                dp[j] = Integer.max(dp[j], item.value + dp[j - item.weight]);
            }
        }
        System.out.println(Arrays.toString(dp));
    }
    return dp[total];
}
```

æ³¨æ„ï¼šå†…å±‚å¾ªç¯éœ€è¦å€’åºï¼Œå¦åˆ™ dp[j - item.weight] çš„ç»“æœä¼šè¢«æå‰è¦†ç›–

### 5) å®Œå…¨èƒŒåŒ…é—®é¢˜

```java
public class KnapsackProblemComplete {
    static class Item {
        int index;
        String name;
        int weight;
        int value;

        public Item(int index, String name, int weight, int value) {
            this.index = index;
            this.name = name;
            this.weight = weight;
            this.value = value;
        }

        @Override
        public String toString() {
            return "Item(" + name + ")";
        }
    }

    public static void main(String[] args) {
        Item[] items = new Item[]{
                new Item(1, "é’é“œ", 2, 3),    // c
                new Item(2, "ç™½é“¶", 3, 4),    // s
                new Item(3, "é»„é‡‘", 4, 7),    // a
        };
        System.out.println(select(items, 6));
    }

    /*
            0   1   2   3   4   5   6
        1   0   0   c   c   cc  cc  ccc
        2   0   0   c   s   cc  cs  ccc
        3   0   0   c   s   a   a   ac
     */

    private static int select(Item[] items, int total) {
        int[][] dp = new int[items.length][total + 1];
        Item item0 = items[0];
        for (int j = 0; j < total + 1; j++) {
            if (j >= item0.weight) {
                dp[0][j] = dp[0][j - item0.weight] + item0.value;
            }
        }
        print(dp);
        for (int i = 1; i < items.length; i++) {
            Item item = items[i];      
            for (int j = 1; j < total + 1; j++) {
                // x: ä¸Šä¸€æ¬¡åŒå®¹é‡èƒŒåŒ…çš„æœ€å¤§ä»·å€¼
            	int x = dp[i - 1][j];
                if (j >= item.weight) {
                    // j-item.weight: å½“å‰èƒŒåŒ…å®¹é‡-è¿™æ¬¡ç‰©å“é‡é‡=å‰©ä½™èƒŒåŒ…ç©ºé—´
                    // y: å‰©ä½™èƒŒåŒ…ç©ºé—´èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼ + è¿™æ¬¡ç‰©å“ä»·å€¼
                    int y = dp[i][j - item.weight] + item.value;
                    dp[i][j] = Integer.max(x, y);
                } else {
                    dp[i][j] = x;
                }
            }
            print(dp);
        }
        return dp[dp.length - 1][total];
    }

    static void print(int[][] dp) {
        System.out.println("   " + "-".repeat(63));
        Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray();
        System.out.printf(("%5d ".repeat(dp[0].length)) + "%n", array);
        for (int[] d : dp) {
            array = Arrays.stream(d).boxed().toArray();
            System.out.printf(("%5d ".repeat(d.length)) + "%n", array);
        }
    }
}
```

#### é™ç»´

```java
private static int select(Item[] items, int total) {
    int[] dp = new int[total + 1];
    for (Item item : items) {
        for (int j = 0; j < total + 1; j++) {
            if (j >= item.weight) {
                dp[j] = Integer.max(dp[j], dp[j - item.weight] + item.value);
            }
        }
        System.out.println(Arrays.toString(dp));
    }
    return dp[total];
}
```

### 6) é›¶é’±å…‘æ¢é—®é¢˜-Leetcode322

```java
public class ChangeMakingProblemLeetcode322 {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[][] dp = new int[coins.length][amount + 1];
        for (int j = 1; j < amount + 1; j++) {
            if (j >= coins[0]) {
                dp[0][j] = 1 + dp[0][j - coins[0]];
            } else {
                dp[0][j] = max;
            }
        }

        for (int i = 1; i < coins.length; i++) {
            for (int j = 1; j < amount + 1; j++) {
                if (j >= coins[i]) {
                    dp[i][j] = Math.min(dp[i - 1][j], 1 + dp[i][j - coins[i]]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
            print(dp);
        }
        int r = dp[coins.length - 1][amount];
        return r > amount ? -1 : r;
    }

    public static void main(String[] args) {
        ChangeMakingProblemLeetcode322 leetcode = new ChangeMakingProblemLeetcode322();
        int count = leetcode.coinChange(new int[]{1, 2, 5}, 5);
//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);
//        int count = leetcode.coinChange(new int[]{2}, 3);
//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);
        System.out.println(count);
    }

    static void print(int[][] dp) {
        System.out.println("-".repeat(18));
        Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray();
        System.out.printf(("%2d ".repeat(dp[0].length)) + "%n", array);
        for (int[] d : dp) {
            array = Arrays.stream(d).boxed().toArray();
            System.out.printf(("%2d ".repeat(d.length)) + "%n", array);
        }
    }
}
```

#### é™ç»´

```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    for (int coin : coins) {
        for (int j = coin; j < amount + 1; j++) {
            dp[j] = Math.min(dp[j], 1 + dp[j - coin]);
        }
    }
    int r = dp[amount];
    return r > amount ? -1 : r;
}
```

#### é›¶é’±å…‘æ¢ II-Leetcode 518

```java
public class ChangeMakingProblemLeetcode518 {
    /*
     é¢å€¼    0        1        2        3        4        5
       1    1        1        1        1        1        1
       2    1        1        2        2        3        3
       5    1        1        2        2        3        4


     é¢å€¼    0        1        2        3
            1        0        0        0
       2    1        0        1        0

     */

    public int change(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int j = coin; j < amount + 1; j++) {
                dp[j] = dp[j] + dp[j - coin];
            }
        }
        return dp[amount];
    }

    public static void main(String[] args) {
        ChangeMakingProblemLeetcode518 leetcode = new ChangeMakingProblemLeetcode518();
        int count = leetcode.change(new int[]{1, 2, 5}, 5);
        System.out.println(count);
    }

}
```

### 7) é’¢æ¡åˆ‡å‰²é—®é¢˜

```java
public class CutRodProblem {
    /*
    1 5 8 9
            0   1   2   3   4
        1       1   11  111 1111
                (1) (2) (3) (4)
        2           11  111 1111
                    2   21  211
                            22
                (1) (5) (6) (10)
        3       1   11  111 1111
                    2   21  211
                        3   22
                            31
                (1) (5) (8) (10)
        4       1   11  111 1111
                    2   21  211
                        3   22
                            31
                            4
                (1) (5) (8) (10)
     */


    static int cut(int[] values, int n) {
        int[][] dp = new int[values.length][n + 1];
        for (int i = 1; i < values.length; i++) {
            int v = values[i];
            for (int j = 1; j < n + 1; j++) {
                if (j >= i) {
                    dp[i][j] = Integer.max(dp[i - 1][j], v + dp[i][j - i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
            print(dp);
        }
        return dp[values.length - 1][n];
    }

    public static void main(String[] args) {
        System.out.println(cut(new int[]{0, 1, 5, 8, 9}, 4));
    }
}
```

#### é™ç»´

```java
static int cut(int[] values, int n) {
    int[] dp = new int[n + 1];
    for (int i = 1; i < values.length; i++) {
        int v = values[i];
        for (int j = i; j < n + 1; j++) {
            dp[j] = Integer.max(dp[j], v + dp[j - i]);
        }
        System.out.println(Arrays.toString(dp));
    }
    return dp[n];
}
```

æœ¬è´¨ä¸Šæ˜¯å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼ŒæŠŠé’¢æ¡æ€»é•¿åº¦çœ‹ä½œèƒŒåŒ…å®¹é‡ï¼Œåˆ‡åˆ†åçš„é’¢æ¡çœ‹ä½œç‰©å“ã€‚åªæ˜¯

* æ­¤æ—¶çš„èƒŒåŒ…å®¹é‡=ç‰©å“æ•°é‡ï¼Œä¾‹å¦‚ï¼Œé’¢æ¡æ€»é•¿åº¦ä¸º4ï¼Œå¯ä»¥çœ‹ä½œæœ‰å››ç§ç‰©å“ï¼š

  * é•¿åº¦1çš„é’¢æ¡
  * é•¿åº¦2çš„é’¢æ¡
  * é•¿åº¦3çš„é’¢æ¡
  * é•¿åº¦4çš„é’¢æ¡
* å¦å¤–ï¼Œè¿™ä¸ªåœºæ™¯ä¸‹ï¼Œæ€»èƒ½è£…æ»¡èƒŒåŒ…

#### ç±»ä¼¼é¢˜ç›® Leetcode-343 æ•´æ•°æ‹†åˆ†

```java
public class Leetcode343 {

    /*
         0   1   2   3   4
     1   1   1   11  111 1111
     2   1   1   11  111 1111
                 2   21  211
                         22
             (1) (2) (2) (4)
     3   1   1   11  111 1111
                 2   21  211
                     3   22
                         31
             (1) (2) (3) (4)
     4   1   1   11  111 1111
                 2   21  211
                     3   22
                         31
                         4
             (1) (2) (3) (4)
     */

    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, 1);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n + 1; j++) {
                if (j >= i) {
                    dp[j] = Integer.max(dp[j], i * dp[j - i]);
                }
            }
            System.out.println(Arrays.toString(dp));
        }
        return dp[n];
    }

    public int integerBreak2(int n) {
        int[][] dp = new int[n][n + 1];
        Arrays.fill(dp[0], 1);
        for (int i = 1; i < n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n + 1; j++) {
                if (j >= i) {
                    dp[i][j] = Integer.max(dp[i - 1][j], i * dp[i][j - i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
            print(dp);
        }
        return dp[n - 1][n];
    }

    public static void main(String[] args) {
        Leetcode343 code = new Leetcode343();
        System.out.println(code.integerBreak(4));
        System.out.println(code.integerBreak(10));
    }
}
```

### 8) æœ€é•¿å…¬å…±å­ä¸²

```java
public class LCSubstring {

    static int lcs(String a, String b) {
        int[][] dp = new int[b.length()][a.length()];
        int max = 0;
        for (int i = 0; i < b.length(); i++) {
            for (int j = 0; j < a.length(); j++) {
                if (a.charAt(j) == b.charAt(i)) {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                    max = Integer.max(dp[i][j], max);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        print(dp, a, b);
        return max;
    }

    static void print(int[][] dp, String a, String b) {
        System.out.println("-".repeat(23));
        Object[] array = a.chars().mapToObj(i -> String.valueOf((char) i)).toArray();
        System.out.printf("  "+"%2s ".repeat(a.length()) + "%n", array);
        for (int i = 0; i < b.length(); i++) {
            int[] d = dp[i];
            array = Arrays.stream(d).boxed().toArray();
            System.out.printf(b.charAt(i) + " " + "%2d ".repeat(d.length) + "%n", array);
        }
    }
    /*
            i   t   h   e   i   m   a
         t  0   1   0   0   0   0   0
         h  0   0   2   0   0   0   0
         e  0   0   0   3   0   0   0
         n  0   0   0   0   0   0   0
     */

    public static void main(String[] args) {
        System.out.println(lcs("itheima", "then"));
    }
}
```

#### ç±»ä¼¼é¢˜ç›® Leetcode-718 æœ€é•¿é‡å¤å­æ•°ç»„

```java
public class Leetcode718 {

    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length + 1;
        int n = nums2.length + 1;
        int[] dp = new int[n];
        int max = 0;
        for (int i = 1; i < m; i++) {
            for (int j = n - 1; j > 0; j--) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                    max = Integer.max(max, dp[j]);
                } else {
                    dp[j] = 0;
                }
            }
        }
        return max;
    }

    public int findLength1(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int[] dp = new int[n];
        int max = 0;
        for (int i = 0; i < m; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (nums1[i] == nums2[j]) {
                    if (i == 0 || j == 0) {
                        dp[j] = 1;
                    } else {
                        dp[j] = dp[j - 1] + 1;
                    }
                    max = Integer.max(max, dp[j]);
                } else {
                    dp[j] = 0;
                }
            }
        }
        return max;
    }

    public int findLength2(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length][nums2.length];
        int max = 0;
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                if (nums1[i] == nums2[j]) {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                    max = Integer.max(max, dp[i][j]);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Leetcode718 code = new Leetcode718();
        System.out.println(code.findLength(new int[]{1, 2, 3, 2, 1}, new int[]{3, 2, 1, 4, 7}));
        System.out.println(code.findLength(new int[]{1, 0, 0, 0, 1}, new int[]{1, 0, 0, 1, 1}));
    }
}
```

### 9) æœ€é•¿å…¬å…±å­åºåˆ—

#### æœ€é•¿å…¬å…±å­åºåˆ—-Leetcode 1143

```java
public class LCSubsequence {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i < m + 1; i++) {
            char a = text1.charAt(i - 1);
            for (int j = 1; j < n + 1; j++) {
                char b = text2.charAt(j - 1);
                if (a == b) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Integer.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        print(dp, text2, text1);
        return dp[m][n];
    }

    static void print(int[][] dp, String a, String b) {
        System.out.println("-".repeat(23));
        Object[] array = a.chars().mapToObj(i -> String.valueOf((char) i)).toArray();
        System.out.printf("     " + "%2s ".repeat(a.length()) + "%n", array);
        for (int i = 0; i < b.length(); i++) {
            int[] d = dp[i + 1];
            array = Arrays.stream(d).boxed().toArray();
            System.out.printf(b.charAt(i) + " " + "%2d ".repeat(d.length) + "%n", array);
        }
    }

    public static void main(String[] args) {
        LCSubsequence code = new LCSubsequence();
        System.out.println(code.longestCommonSubsequence("abcde", "ace"));
        System.out.println(code.longestCommonSubsequence("ba", "yby"));
    }
}
```

#### ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ-Leetcode 583

```java
public class Leetcode538 {
    public static void main(String[] args) {
        Leetcode538 code = new Leetcode538();
        System.out.println(code.minDistance("leetcode", "etco"));  // 4
        System.out.println(code.minDistance("eat", "sea"));		   // 2
        System.out.println(code.minDistance("park", "spake"));	   // 3
    }

    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        char[] chars1 = word1.toCharArray();
        char[] chars2 = word2.toCharArray();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i < m + 1; i++) {
            int x = chars1[i - 1];
            for (int j = 1; j < n + 1; j++) {
                int y = chars2[j - 1];
                if (x == y) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Integer.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return m + n - dp[m][n] - dp[m][n];
    }
}
```

### 10) æœ€é•¿ä¸Šå‡å­åºåˆ—-Leetcode 300

```java
public class Leetcode300 {
    /*
                    1       2       3       4
            1       3       6       4       9
            1       13      16      14      19
                            136     134     139
                                            169
                                            1369
                                            149
                                            1349
           (1)    (2)      (3)     (3)      (4)
                                            4
     */
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) { // æ»¡è¶³äº†å‡åºæ¡ä»¶
                    // ç”¨ä¹‹å‰é€’å¢å­åºåˆ—çš„æœ€å¤§é•¿åº¦ + 1 æ›´æ–°å½“å‰é•¿åº¦
                    dp[i] = Integer.max(dp[i], dp[j] + 1);
                }
            }
            System.out.println(Arrays.toString(dp));
        }
        return Arrays.stream(dp).max().getAsInt();
    }

    public static void main(String[] args) {
        Leetcode300 code = new Leetcode300();
        System.out.println(code.lengthOfLIS(new int[]{1, 3, 6, 4, 9}));
//        System.out.println(code.lengthOfLIS(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));
//        System.out.println(code.lengthOfLIS(new int[]{1, 3, 6, 7, 9, 4, 10, 5, 6}));
        //                                            1 3 6 7 9 10  = 6
        //                                            1 3 4 5 6     = 5
//        System.out.println(code.lengthOfLIS(new int[]{0, 1, 0, 3, 2, 3}));
//        System.out.println(code.lengthOfLIS(new int[]{7, 7, 7, 7, 7, 7, 7}));
    }
}
```

### 11) Catalan æ•°

```java
public class Catalan {
    public static void main(String[] args) {
        System.out.println(catalan(6));
    }

    static int catalan(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            for (int j = 0; j < i; j++) {
                System.out.print("(" + j + " " + (i - 1 - j) + ")\t");
                dp[i] += dp[j] * dp[i - 1 - j];
            }
            System.out.println();
            System.out.println(Arrays.toString(dp));
        }
        return dp[n];
    }
}
```

#### Leetcode-96 ä¸åŒçš„äºŒå‰æœç´¢æ ‘

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int j = 2; j < n + 1; j++) {
            for (int i = 0; i < j; i++) { 
                dp[j] += dp[i] * dp[j - 1 - i];
            }
        }
        return dp[n];
    }
}
```

#### Leetcode-22 æ‹¬å·ç”Ÿæˆ

```java
public class Leetcode22 {

    public List<String> generateParenthesis(int n) {
        ArrayList<String>[] dp = new ArrayList[n + 1];
        dp[0] = new ArrayList<>(List.of(""));
        dp[1] = new ArrayList<>(List.of("()"));
        for (int j = 2; j < n + 1; j++) {
            dp[j] = new ArrayList<>();
            for (int i = 0; i < j; i++) { // ç¬¬jä¸ªå¡ç‰¹å…°æ•°çš„æ‹†åˆ†
                System.out.printf("(%d,%d)\t", i, j - 1 - i);
//                dp[j] += dp[i] * dp[j - 1 - i];
//                dp[j].add("(" + dp[i] + ")" + dp[j - 1 - i]);
                for (String k1 : dp[i]) {
                    for (String k2 : dp[j - 1 - i]) {
                        dp[j].add("(" + k1 + ")" + k2);
                    }
                }
            }
            System.out.println(dp[j]);
        }
        return dp[n];
    }

    public static void main(String[] args) {
        Leetcode22 code = new Leetcode22();
        System.out.println(code.generateParenthesis(4));
    }
}
```

#### ä¹°ç¥¨æ‰¾é›¶é—®é¢˜

å”®ç¥¨å¤„å”®å–çƒç¥¨ï¼Œæ¯å¼ ç¥¨ 50 å…ƒã€‚æœ‰2näººå‰æ¥ä¹°ç¥¨

* å…¶ä¸­ä¸€åŠäººæ‰‹æŒ 50 å…ƒé’ç¥¨
* å¦ä¸€åŠäººæ‰‹æŒ 100 å…ƒé’ç¥¨

è‹¥å”®ç¥¨å¤„å¼€å§‹æ²¡æœ‰ä»»ä½•é›¶é’±ï¼Œé—®ï¼šæœ‰å¤šå°‘ç§æ’é˜Ÿæ–¹å¼ï¼Œèƒ½å¤Ÿè®©å”®ç¥¨é¡ºç•…è¿›è¡Œã€‚

æ€è·¯ï¼š

* æŠŠæ‰‹æŒ 50 å…ƒé’ç¥¨çš„äººè§†ä¸ºå·¦æ‹¬å·
* æŠŠæ‰‹æŒ 100 å…ƒé’ç¥¨çš„äººè§†ä¸ºå³æ‹¬å·
* å·¦å³æ‹¬å·åˆæ³•é…å¯¹ï¼Œå³å…ˆå‡ºç°å·¦æ‹¬å·ï¼Œå†å‡ºç°å³æ‹¬å·ï¼Œå°±å¯ä»¥è®©å”®ç¥¨é¡ºç•…æ‰§è¡Œ

å¯ä»¥çœ‹åˆ°ï¼Œé—®é¢˜åˆå˜æˆäº†æ±‚è§£ n çš„å¡ç‰¹å…°æ•°

#### å…¶å®ƒé—®é¢˜

| é¢˜å·         | æ ‡é¢˜                   |
| ------------ | ---------------------- |
| Leetcode 331 | éªŒè¯äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ– |
| Leetcode 894 | æ‰€æœ‰å¯èƒ½çš„æ»¡äºŒå‰æ ‘     |
|              |                        |

### 12) æ‰“å®¶åŠ«èˆ-Leetcode 198

```java
public class HouseRobberLeetcode198 {

    /*
        æˆ¿å­ä»·å€¼
              0   1   2   3   4
              2   7   9   3   1

              0   1   2   3   4
              0   0   0   0   0
              2   7   11  10  12


              0   1   2   3
              2   1   1   2

              0   1   2   3
              2   2   3   4
     */

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return nums[0];
        }
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Integer.max(nums[0], nums[1]);
        for (int i = 2; i < len; i++) {
            dp[i] = Integer.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[len - 1];
    }

    public static void main(String[] args) {
        HouseRobberLeetcode198 code = new HouseRobberLeetcode198();
        System.out.println(code.rob(new int[]{2, 7, 9, 3, 1}));
        System.out.println(code.rob(new int[]{2, 1, 1, 2}));
    }
}
```

### 13) Travelling salesman problem

æ—…è¡Œå•†é—®é¢˜

![image-20230731213127478](./imgs/image-20230731213127478.png)

java ä»£ç 

```java
public class TravellingSalesmanProblem {

    /*
            0   1   2   3
        0   0   1   2   3
        1   1   0   6   4
        2   2   6   0   5
        3   3   4   5   0

        d(0,{1,2,3}) => c01+d(1,{2,3}) => c12+d(2,{3}) => c23+d(3,{})
                                          c13+d(3,{2}) => c32+d(2,{})
                        c02+d(2,{1,3}) => c21+d(1,{3}) => c13+d(3,{})
                                          c23+d(3,{1}) => c31+d(1,{})
                        c03+d(3,{1,2}) => c31+d(1,{2}) => c12+d(2,{})
                                          c32+d(2,{1}) => c21+d(1,{})

        d(0,{1}) => c01+d(1,{}) 0->1->0
        d(1,{1})
        d(2,{1}) => c21+d(1,{}) 2->1->0
        d(3,{1}) => c31+d(1,{}) 3->1->0

        d(0,{2}) => c02+d(2,{}) 0->2->0
        d(1,{2}) => c12+d(2,{}) 1->2->0
        d(2,{2})
        d(3,{2}) => c32+d(2,{}) 3->2->0

        d(0,{1,2}) => c01+d(1,{2}) => 0->1->2->0
                      c02+d(2,{1}) => 0->2->1->0
        d(3,{1,2}) => c31+d(1,{2}) => 3->1->2->0
                      c32+d(2,{1}) => 3->2->1->0

        d(0,{3}) => c03+d(3,{}) 0->3->0
        d(1,{3}) => c13+d(3,{}) 1->3->0
        d(2,{3}) => c23+d(3,{}) 2->3->0
        d(3,{3})

        d(0,{1,3}) => c01+d(1,{3}) => 0->1->3->0
                      c03+d(3,{1}) => 0->3->1->0
        d(2,{1,3}) => c21+d(1,{3}) => 2->1->3->0
                      c23+d(3,{1}) => 2->3->1->0


        d(0,{2,3}) => c02+d(2,{3}) => 0->2->3->0
                      c03+d(3,{2}) => 0->3->2->0
        d(1,{2,3}) => c12+d(2,{3}) => 1->2->3->0
                      c13+d(3,{2}) => 1->3->2->0

        d(0,{1,2,3}) => c01+d(1,{2,3})  11+1
                        c02+d(2,{1,3})  10+2
                        c03+d(3,{1,2})  12+3

            0       1       2       12      3       13      23      123
            0       1       2       3       4       5       6       7
       0    0       2       4       9       6       8       10      12
       1    1       _       8       _       7       _       11      _
       2    2       7       _       _       8       10      _       _
       3    3       5       7       12      _       _       _       _

     */


    public static void main(String[] args) {
        int[][] graph = {
                {0, 1, 2, 3},
                {1, 0, 6, 4},
                {2, 6, 0, 5},
                {3, 4, 5, 0},
        };
//        System.out.println(tsp(graph));
        System.out.println(6 >> (0-1));
    }

    static int tsp1(int[][] graph) {
        int n = graph.length;
        int[][] dp = new int[1 << n][n];
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE / 2);
        }
        dp[1][0] = 0;
        for (int mask = 1; mask < 1 << n; mask++) {
            for (int i = 0; i < n; i++) {
                if ((mask & 1 << i) == 0) continue;
                for (int j = 0; j < n; j++) {
                    if ((mask & 1 << j) != 0) continue;
                    dp[mask | 1 << j][j] = Math.min(dp[mask | 1 << j][j], dp[mask][i] + graph[i][j]);
                }
            }
            print(dp);
        }

        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.min(res, dp[(1 << n) - 1][i] + graph[i][0]);
        }
        return res;
    }

    /*
        110 æ˜¯å¦åŒ…å« 0 = 0 & 1 = 0
        110 æ˜¯å¦åŒ…å« 1 = 110 & 1 = 0
        110 æ˜¯å¦åŒ…å« 2 = 11 & 1 = 1
        110 æ˜¯å¦åŒ…å« 3 = 1 & 1 = 1
        110 æ˜¯å¦åŒ…å« 4 = 0 & 1 = 0
     */
    static boolean contains(int set, int city) {
        return (set >> (city - 1) & 1) == 1;
    }

    /*
        110     110
       ^100    ^010
       ----    ----
         10     100

     */
    static int exclude(int set, int city) {
        return set ^ (1 << (city - 1));
    }

    static int tsp(int[][] g) {
        int n = g.length;
        int m = 1 << (n - 1);
        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            dp[i][0] = g[i][0];
        }
        for (int j = 1; j < m; j++) {
            for (int i = 0; i < n; i++) {
                dp[i][j] = Integer.MAX_VALUE / 2;
                if (contains(j, i)) continue;
                for (int k = 1; k < n; k++) {
                    if (contains(j, k)) {
//                    System.out.println("(" + k + "," + (j ^ (1 << (k - 1))) + ")");
                        dp[i][j] = Math.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]);
                    }
                }
            }
            print(dp);
        }

        return dp[0][m - 1];
    }

    static void print(int[][] dist) {
        System.out.println("-------------------------");
        for (int[] row : dist) {
            System.out.println(Arrays.stream(row).boxed()
                    .map(x -> x >= Integer.MAX_VALUE / 2 ? "âˆ" : String.valueOf(x))
                    .map(s -> String.format("%2s", s))
                    .collect(Collectors.joining(",", "[", "]")));
        }
    }
}
```

### å…¶å®ƒé¢˜ç›®

| é¢˜å·         | æ ‡é¢˜             |
| ------------ | ---------------- |
| æ—            | é›†åˆè¦†ç›–é—®é¢˜     |
| æ—            | æ‰”é¸¡è›‹é—®é¢˜       |
| Leetcode 72  | ç¼–è¾‘è·ç¦»         |
| Leetcode 121 | ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº |

#### ç»„åˆæ€»å’Œ IV-Leetcode 377

ä¸è¦è¢«é¢˜ç›®åå­—è¯¯å¯¼äº†ï¼Œæœ¬é¢˜ç±»ä¼¼äºé›¶é’±å…‘æ¢518é¢˜ï¼ŒåŒºåˆ«åœ¨äºé›¶é’±å…‘æ¢æ±‚çš„æ˜¯ç»„åˆæ•°ï¼Œæœ¬é¢˜æ±‚çš„æ˜¯æ’åˆ—æ•°

```java
public class CombinationLeetcode377 {
    static int combinationSum4(int[] nums, int target) {
        return change(nums, target);
    }

    /*
            0       1       2       3       4 æ€»é‡‘é¢
        1           1       11      111     1111
        2           1       11      111     1111
                            2       12      112
                                    21      121
                                            22
                                            211
        3           1       11      111     1111
                            2       12      112
                                    21      121
                                    3       13
                                            211
                                            22
                                            31
        é¢å€¼
        dp[j] = dp[j-1] + dp[j-2] + dp[j-3]
     */

    static int change(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int j = 1; j < amount + 1; j++) {
            for (int coin : coins) {
                if (j >= coin) {
                    dp[j] += dp[j - coin];
                }
            }
            System.out.println(Arrays.toString(dp));
        }
        return dp[amount];
    }

    public static void main(String[] args) {
        System.out.println(combinationSum4(new int[]{1, 2, 3}, 4));
    }
}
```

## 4.4 Divide and Conquer

### 1) æ¦‚è¿°

åˆ†æ²»æ€æƒ³

- å°†å¤§é—®é¢˜åˆ’åˆ†ä¸ºä¸¤ä¸ªåˆ°å¤šä¸ªå­é—®é¢˜
- å­é—®é¢˜å¯ä»¥ç»§ç»­æ‹†åˆ†æˆæ›´å°çš„å­é—®é¢˜ï¼Œç›´åˆ°èƒ½å¤Ÿç®€å•æ±‚è§£
- å¦‚æœ‰å¿…è¦ï¼Œå°†å­é—®é¢˜çš„è§£è¿›è¡Œåˆå¹¶ï¼Œå¾—åˆ°åŸå§‹é—®é¢˜çš„è§£

ä¹‹å‰å­¦è¿‡çš„ä¸€äº›ç»å…¸åˆ†è€Œæ²»ä¹‹çš„ä¾‹å­

* äºŒåˆ†æŸ¥æ‰¾
* å¿«é€Ÿæ’åº
* å½’å¹¶æ’åº
* åˆå¹¶Kä¸ªæ’åºé“¾è¡¨ - LeetCode 23

#### äºŒåˆ†æŸ¥æ‰¾

![image-20230802100240290](./imgs/image-20230802100240290.png)

```java
public static int binarySearch(int[] a, int target) {
    return recursion(a, target, 0, a.length - 1);
}

public static int recursion(int[] a, int target, int i, int j) {
    if (i > j) {
        return -1;
    }
    int m = (i + j) >>> 1;
    if (target < a[m]) {
        return recursion(a, target, i, m - 1);
    } else if (a[m] < target) {
        return recursion(a, target, m + 1, j);
    } else {
        return m;
    }
}
```

å‡è€Œæ²»ä¹‹ï¼Œæ¯æ¬¡æœç´¢èŒƒå›´å†…å…ƒç´ å‡å°‘ä¸€åŠ

#### å¿«é€Ÿæ’åº

![image-20230802100332341](./imgs/image-20230802100332341.png)

```java
public static void sort(int[] a) {
    quick(a, 0, a.length - 1);
}

private static void quick(int[] a, int left, int right) {
    if (left >= right) {
        return;
    }
    int p = partition(a, left, right);
    quick(a, left, p - 1);
    quick(a, p + 1, right);
}
```

åˆ†è€Œæ²»ä¹‹ï¼Œè¿™æ¬¡åˆ†åŒºåŸºå‡†ç‚¹ï¼Œåœ¨åˆ’åˆ†åä¸¤ä¸ªåŒºåŸŸåˆ†åˆ«è¿›è¡Œä¸‹æ¬¡åˆ†åŒº

#### å½’å¹¶æ’åº

![image-20230513143854887](./imgs/image-20230513143854887.png)

```java
public static void sort(int[] a1) {
    int[] a2 = new int[a1.length];
    split(a1, 0, a1.length - 1, a2);
}

private static void split(int[] a1, int left, int right, int[] a2) {
    int[] array = Arrays.copyOfRange(a1, left, right + 1);
    // 2. æ²»
    if (left == right) {
        return;
    }
    // 1. åˆ†
    int m = (left + right) >>> 1;
    split(a1, left, m, a2);           
    split(a1, m + 1, right, a2);   
    // 3. åˆ
    merge(a1, left, m, m + 1, right, a2);
    System.arraycopy(a2, left, a1, left, right - left + 1);
}
```

åˆ†è€Œæ²»ä¹‹ï¼Œåˆ†åˆ°åŒºé—´å†…åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œåˆå¹¶åŒºé—´

#### åˆå¹¶Kä¸ªæ’åºé“¾è¡¨ - LeetCode 23

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) {
        return null;
    }
    return split(lists, 0, lists.length - 1);
}

public ListNode split(ListNode[] lists, int i, int j) {
    System.out.println(i + " " + j);
    if (j == i) {
        return lists[i];
    }
    int m = (i + j) >>> 1;
    return mergeTwoLists(
        split(lists, i, m),
        split(lists, m + 1, j)
    );
}
```

åˆ†è€Œæ²»ä¹‹ï¼Œåˆ†åˆ°åŒºé—´å†…åªæœ‰ä¸€ä¸ªé“¾è¡¨ï¼Œåˆå¹¶åŒºé—´

#### å¯¹æ¯”åŠ¨æ€è§„åˆ’

* éƒ½éœ€è¦æ‹†åˆ†å­é—®é¢˜
* åŠ¨æ€è§„åˆ’çš„å­é—®é¢˜æœ‰é‡å ã€å› æ­¤éœ€è¦è®°å½•ä¹‹å‰å­é—®é¢˜è§£ï¼Œé¿å…é‡å¤è¿ç®—
* åˆ†è€Œæ²»ä¹‹çš„å­é—®é¢˜æ— é‡å 

### 2) å¿«é€Ÿé€‰æ‹©ç®—æ³•

```java
public class Utils {
    static int quick(int[] a, int left, int right, int index) {
        int p = partition(a, left, right);
        if (p == index) {
            return a[p];
        }
        if (p < index) {
            return quick(a, p + 1, right, index);
        } else {
            return quick(a, left, p - 1, index);
        }
    }

    static int partition(int[] a, int left, int right) {
        int idx = ThreadLocalRandom.current().nextInt(right - left + 1) + left;
        swap(a, left, idx);
        int pv = a[left];
        int i = left + 1;
        int j = right;
        while (i <= j) {
            // i ä»å·¦å‘å³æ‰¾å¤§çš„æˆ–è€…ç›¸ç­‰çš„
            while (i <= j && a[i] < pv) {
                i++;
            }
            // j ä»å³å‘å·¦æ‰¾å°çš„æˆ–è€…ç›¸ç­‰çš„
            while (i <= j && a[j] > pv) {
                j--;
            }
            if (i <= j) {
                swap(a, i, j);
                i++;
                j--;
            }
        }
        swap(a, j, left);
        return j;
    }

    static void swap(int[] a, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}
```

#### æ•°ç»„ä¸­ç¬¬kä¸ªæœ€å¤§å…ƒç´ -Leetcode 215

```java
public class FindKthLargestLeetcode215 {
    /*
        ç›®æ ‡ index = 4
            3   2   1   5   6   4
        =>  3   2   1   4   5   6   (3)
        =>  3   2   1   4   5   6   (5)
        =>  3   2   1   4   5   6   (4)
     */

    public int findKthLargest(int[] a, int k) {
        return Utils.quick(a, 0, a.length - 1, a.length - k);
    }

    public static void main(String[] args) {
        // åº”ä¸º5
        FindKthLargestLeetcode215 code = new FindKthLargestLeetcode215();
        System.out.println(code.findKthLargest(new int[]{3, 2, 1, 5, 6, 4}, 2));
        // åº”ä¸º4
        System.out.println(code.findKthLargest(new int[]{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4));
    }
}
```

#### æ•°ç»„ä¸­ä½æ•°

```java
public class FindMedian {
    /*
        å¶æ•°ä¸ª
            3   1   5   4
        å¥‡æ•°ä¸ª
            4   5   1
            4   5   1   6   3
     */
    public static double findMedian(int[] nums) {
        if (nums.length % 2 != 0) {
            return findIndex(nums, nums.length / 2);
        } else {
            System.out.println((nums.length / 2 - 1) + "," + (nums.length / 2));
            int a = findIndex(nums, nums.length / 2);
            int b = findIndex(nums, nums.length / 2 - 1);
            return (a + b) / 2.0;
        }
    }

    public static void main(String[] args) {
        System.out.println(findMedian(new int[]{3, 1, 5, 4}));
        System.out.println(findMedian(new int[]{3, 1, 5, 4, 7, 8}));
        System.out.println(findMedian(new int[]{4, 5, 1}));
        System.out.println(findMedian(new int[]{4, 5, 1, 6, 3}));
    }

    static int findIndex(int[] a, int index) {
        return Utils.quick(a, 0, a.length - 1, index);
    }

}
```

### 3) å¿«é€Ÿå¹‚-Leetcode 50

```java
public class QuickPowLeetcode50 {

    /*
                  2^10
              /         \
            2^5         2^5
           /  \        /  \
        2 2^2 2^2    2 2^2 2^2
         / \  / \     / \  / \
        2  2  2  2   2  2  2  2


                  256          n=1 x=65536 mul=1024
              /         \
            16          16          n=2 x=256 mul=4
           /  \        /  \
        2 4    4    2  4    4       n=5  x=16 mul=4
         / \  / \     / \  / \
        2  2  2  2   2  2  2  2     n=10  x=4  mul=1

     */

  
    static double myPow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        double mul = 1;
        long N = n;
        if (n < 0) {
            N = -N;
        }
        while (N > 0) {
            if ((N & 1) == 1) {
                mul *= x;
            }
            x =  x * x;
            N = N >> 1;
        }
        return n > 0 ? mul : 1 / mul;
    }
  
    static double myPow1(double x, int n) {
        long N = n;
        if (N < 0) {
            return 1.0 / rec(x, -N);
        }
        return rec(x, n);
    }

    static double rec(double x, long n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return x;
        }
        double y = rec(x, n / 2);
        if ((n & 1) == 1) {
            return x * y * y;
        }
        return y * y;
    }

    public static void main(String[] args) {
        System.out.println(myPow(2, 10));  // 1024.0
        System.out.println(myPow(2.1, 3)); // 9.261
        System.out.println(myPow(2, -2)); // 0.25
        System.out.println(myPow(2, 0)); // 1.0
        System.out.println(myPow(2, -2147483648)); // 1.0
    }
}
```

### 4) å¹³æ–¹æ ¹æ•´æ•°éƒ¨åˆ†-Leetcode 69

```java
public class SqrtLeetcode69 {
    static int mySqrt(int x) {
        int i = 1, j = x;
        int r = 0;
        while (i <= j) {
            int m = (i + j) >>> 1;
            if (x / m >= m) {
                r = m;
                i = m+1;
            } else {
                j = m-1;
            }
        }
        return r;
    }

    public static void main(String[] args) {
        System.out.println(mySqrt(1));
        System.out.println(mySqrt(2));
        System.out.println(mySqrt(4));
        System.out.println(mySqrt(8));
        System.out.println(mySqrt(9));
    }
}
```

* `while(i <= j)` å«ä¹‰æ˜¯åœ¨æ­¤åŒºé—´å†…ï¼Œåªè¦æœ‰æ•°å­—è¿˜æœªå°è¯•ï¼Œå°±ä¸ç®—ç»“æŸ
* r çš„ä½œç”¨æ˜¯ä¿ç•™æœ€è¿‘ä¸€æ¬¡å½“ $m^2 <= x$ çš„ m çš„å€¼
* ä½¿ç”¨é™¤æ³•è€Œéä¹˜æ³•ï¼Œé¿å…å¤§æ•°ç›¸ä¹˜è¶Šç•Œ

### 5) è‡³å°‘kä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²-Leetcode 395

```java
public class LongestSubstringLeetcode395 {

    static int longestSubstring(String s, int k) {
        // å­ä¸²è½é€‰æƒ…å†µ
        if (s.length() < k) {
            return 0;
        }
        int[] counts = new int[26]; // ç´¢å¼•å¯¹åº”å­—ç¬¦ å€¼ç”¨æ¥å­˜å‚¨è¯¥å­—ç¬¦å‡ºç°äº†å‡ æ¬¡
        char[] chars = s.toCharArray();
        for (char c : chars) { // 'a' -> 0  'b' -> 1 ....
            counts[c - 'a']++;
        }
        System.out.println(Arrays.toString(counts));
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            int count = counts[c - 'a']; // iå­—ç¬¦å‡ºç°æ¬¡æ•°
            if (count > 0 && count < k) {
                int j = i + 1;
                while(j < s.length() && counts[chars[j] - 'a'] < k) {
                    j++;
                }
                System.out.println(s.substring(0, i) + "\t" + s.substring(j));
                return Integer.max(
                        longestSubstring(s.substring(0, i), k),
                        longestSubstring(s.substring(j), k)
                );
            }
        }
        // å­ä¸²å…¥é€‰æƒ…å†µ
        return s.length();
    }

    public static void main(String[] args) {
        //                                         i j
        System.out.println(longestSubstring("aaaccbbb", 3)); // ababb
        System.out.println(longestSubstring("dddxaabaaabaacciiiiefbff", 3));
//        System.out.println(longestSubstring("ababbc", 3)); // ababb
//        System.out.println(longestSubstring("ababbc", 2)); // ababb
        /*
            ddd aabaaabaa iiii fbff
                aa aaa aa      f ff

            ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°ï¼Œç§»é™¤å“ªäº›å‡ºç°æ¬¡æ•° < k çš„å­—ç¬¦
            å‰©ä½™çš„å­ä¸²ï¼Œé€’å½’åšæ­¤å¤„ç†ï¼Œç›´è‡³
                 - æ•´ä¸ªå­ä¸²é•¿åº¦ < k (æ’é™¤)
                 - å­ä¸²ä¸­æ²¡æœ‰å‡ºç°æ¬¡æ•° < k çš„å­—ç¬¦
         */
    }
}
```

## 4.5 Backtracking Algorithm

### 1) å…¥é—¨ä¾‹å­

```java
public class Backtracking {
    public static void main(String[] args) {
        rec(1, new LinkedList<>());
    }

    static void rec(int n, LinkedList<String> list) {
        if (n == 3) {
            return;
        }
        System.out.println("before:" + list);
        list.push("a");
        rec(n + 1, list);
        list.pop();
        System.out.println("after:" + list);
    }
}
```

### 2) å…¨æ’åˆ—-Leetcode 46

```java
public class PermuteLeetcode46 {
    static List<List<Integer>> permute(int[] nums) {
        boolean[] visited = new boolean[nums.length];
        LinkedList<Integer> stack = new LinkedList<>();
        List<List<Integer>> r = new ArrayList<>();
        rec(nums, visited, stack, r);
        return r;
    }

    static void rec(int[] nums, boolean[] visited, LinkedList<Integer> stack, List<List<Integer>> r) {
        if (stack.size() == nums.length) {
            r.add(new ArrayList<>(stack));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(visited[i]){
                continue;
            }
            stack.push(nums[i]);
            visited[i] = true;
            rec(nums, visited, stack, r);
            stack.pop();
            visited[i] = false;
        }
    }

    public static void main(String[] args) {
        List<List<Integer>> permute = permute(new int[]{1, 2, 3});
        for (List<Integer> s : permute) {
            System.out.println(s);
        }
    }
}
```

### 3) å…¨æ’åˆ—II-Leetcode 47

```java
public class PermuteLeetcode47 {

    static List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        dfs(nums, new boolean[nums.length], new LinkedList<>(), result);
        return result;
    }

    static void dfs(int[] nums, boolean[] visited, LinkedList<Integer> stack, List<List<Integer>> result) {
        if (stack.size() == nums.length) {
            result.add(new ArrayList<>(stack));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && !visited[i-1]) { // æ‰¾å‡ºé‡å¤æ•°å­—
                continue;
            }
            if (!visited[i]) {
                stack.push(nums[i]);
                visited[i] = true;
                dfs(nums, visited, stack, result);
                visited[i] = false;
                stack.pop();
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 1, 3};  
        List<List<Integer>> permute = permuteUnique(nums);
        for (List<Integer> list : permute) {
            System.out.println(list);
        }
    }
}
```

* æ’å¥½åºï¼Œè¿™æ ·é‡å¤çš„æ•°å­—ä¼šç›¸é‚»
* å®šå¥½è§„åˆ™ï¼šå¿…é¡» 1 å›ºå®šä¹‹åæ‰èƒ½å›ºå®š 1'ï¼Œå³ 1 çš„ visited = true æ‰èƒ½ç»§ç»­å¤„ç† 1'
* åœ¨éå†æ—¶ï¼Œé‡åˆ°äº† `nums[i] == nums[i - 1]`ï¼ˆå³ 1 å’Œ 1â€˜ è¿™ç§æƒ…å†µï¼‰ï¼Œè¿›ä¸€æ­¥æ£€æŸ¥ i-1 ä½ç½®çš„æ•°å­—æœ‰æ²¡æœ‰ visitedï¼Œæ²¡æœ‰ï¼Œåˆ™ä¸å¤„ç†ï¼ˆå‰ªæï¼‰

### 4) ç»„åˆ-Leetcode 77

```java
public class CombinationLeetcode77 {
    static List<List<Integer>> combinationSum(int n, int k) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(n, k, 1, new LinkedList<>(), result);
        return result;
    }
    static int count = 0;

    static void dfs(int n, int k, int start, LinkedList<Integer> stack, List<List<Integer>> result) {
        count++;
        if (k == 0) {
            result.add(new ArrayList<>(stack));
            System.out.println(stack);
            return;
        }
//      if (k > n - start + 1) { return; }
        for (int i = start; i <= n; i++) {
//            System.out.printf("k-1=%d n=%d i=%d %n", k - 1, n, i);
            if (k > n - i + 1) {
                continue;
            }
            stack.push(i);
            dfs(n, k - 1, i + 1, stack, result);
            stack.pop();
        }
    }

    public static void main(String[] args) {
        List<List<Integer>> lists = combinationSum(5, 4);
//        for (List<Integer> list : lists) {
//            System.out.println(list);
//        }
        System.out.println(count);
    }
}
```

* k ä»£è¡¨å‰©ä½™è¦ç»„åˆçš„ä¸ªæ•°
* `n - i + 1` ä»£è¡¨å‰©ä½™å¯ç”¨æ•°å­—
* å‰ªææ¡ä»¶æ˜¯ï¼šå‰©ä½™å¯ç”¨æ•°å­—è¦å¤§äºå‰©ä½™ç»„åˆæ•°
* ä¸ºå•¥æ”¾åœ¨å¤–é¢ä¸è¡Œï¼Ÿå³è¿™è¡Œä»£ç ï¼š`if (k > n - start + 1) { return; }`
  * å› ä¸ºå®ƒåªè€ƒè™‘äº† start ä¸€ç§æƒ…å†µï¼Œè€Œå®é™…åœ¨å¾ªç¯å†…è¦å¤„ç†çš„æ˜¯ startï¼Œstart+1 ... n è¿™å¤šç§æƒ…å†µ

ä¼¼ä¹ ArrayList ä½œä¸º stack æ€§èƒ½é«˜ä¸€äº›ï¼Œè§ä¸‹é¢ä»£ç ï¼Œä½†æ˜¯è¿™é“é¢˜åœ¨ leetcode ä¸Šæ‰§è¡Œæ—¶é—´ä¸ç¨³å®šï¼Œç›¸åŒä»£ç éƒ½ä¼šæœ‰è¾ƒå¤§æ—¶é—´å·®å¼‚ï¼ˆ15ms vs 9msï¼‰

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {  
        List<List<Integer>> result = new ArrayList<>();
        if(k == 0 || n < k) return result;
        dfs(n, k, 1, new ArrayList<>(), result);
        return result;
    }

    static void dfs(int n, int k, int start, ArrayList<Integer> stack, List<List<Integer>> result) {
        if (k == 0) {
            result.add(new ArrayList<>(stack));
            return;
        }
        for (int i = start; i <= n; i++) {
            if (k-1 > n - i) {
                continue;
            }
            stack.add(i);
            dfs(n, k - 1, i + 1, stack, result);
            stack.remove(stack.size()-1);
        }
    }
}
```

### 5) ç»„åˆæ€»å’Œ-Leetcode 39

```java
public class CombinationLeetcode39 {
    static List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(target, 0,candidates, new LinkedList<>(), result);
        return result;
    }

    static void dfs(int target, int start, int[] candidates, LinkedList<Integer> stack, List<List<Integer>> result) {
        if (target == 0) {
            result.add(new ArrayList<>(stack));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int candidate = candidates[i];
            if (target < candidate) {
                continue;
            }
            stack.push(candidate);
            dfs(target - candidate, i, candidates, stack, result);
            stack.pop();
        }
    }

    public static void main(String[] args) {
        List<List<Integer>> lists = combinationSum(new int[]{6, 3, 2, 7}, 7);
        for (List<Integer> list : lists) {
            System.out.println(list);
        }
    }
}
```

ä¸ä¹‹å‰çš„é›¶é’±å…‘æ¢é—®é¢˜å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯

* æœ¬é¢˜æ±‚çš„æ˜¯ï¼šæ‰€æœ‰ç»„åˆçš„å…·ä½“ä¿¡æ¯
* é›¶é’±å…‘æ¢é—®é¢˜æ±‚çš„æ˜¯ï¼šæ‰€æœ‰ç»„åˆä¸­æ•°å­—æœ€å°‘çš„ã€æ‰€æœ‰ç»„åˆä¸ªæ•°...

### 6) ç»„åˆæ€»å’Œ II-Leetcode 40

```java
public class CombinationLeetcode40 {
    static List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result = new ArrayList<>();
        dfs(target, 0, candidates, new boolean[candidates.length], new LinkedList<>(), result);
        return result;
    }

    static void dfs(int target, int start, int[] candidates, boolean[] visited, LinkedList<Integer> stack, List<List<Integer>> result) {
        if (target == 0) {
            result.add(new ArrayList<>(stack));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int candidate = candidates[i];
            if (target < candidate) {
                continue;
            }
            if (i > 0 && candidate == candidates[i - 1] && !visited[i - 1]) {
                continue;
            }
            visited[i] = true;
            stack.push(candidate);
            dfs(target - candidate, i + 1, candidates, visited, stack, result);
            stack.pop();
            visited[i] = false;
        }
    }

    public static void main(String[] args) {
        int[] candidates = {10, 1, 2, 7, 6, 1, 5};  
        List<List<Integer>> lists = combinationSum2(candidates, 8);
        for (List<Integer> list : lists) {
            System.out.println(list);
        }
    }
}
```

### 7) ç»„åˆæ€»å’Œ III-Leetcode 216

```java
public class CombinationLeetcode216 {
    // æ­¤ target ä»£è¡¨æ•°å­—ç»„åˆåçš„å’Œ
    static List<List<Integer>> combinationSum3(int k, int target) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(1, target, k, new LinkedList<>(), result);
        return result;
    }

    static int count = 0;

    static void dfs(int start, int target, int k,
                    LinkedList<Integer> stack,
                    List<List<Integer>> result) {
//        System.out.println(stack);
        count++;
        if (target == 0 && stack.size() == k) {
            result.add(new ArrayList<>(stack));
            return;
        }
        for (int i = start; i <= 9; i++) {
            //  è¿˜å·®å‡ ä¸ªæ•°å­—          å‰©ä½™å¯ç”¨æ•°å­—
            /*if (k - stack.size() > 9 - i + 1) {
                continue;
            }*/
            if(target < i){
                continue;
            }
            if(stack.size() == k) {
                continue;
            }
            stack.push(i);
            dfs(i + 1, target - i, k, stack, result);
            stack.pop();
        }
    }

    public static void main(String[] args) {
//        List<List<Integer>> lists = combinationSum3(3, 7);
        List<List<Integer>> lists = combinationSum3(2, 18); // 9 8
        for (List<Integer> list : lists) {
            System.out.println(list);
        }
        System.out.println(count);
    }
}
```

è¿™é“é¢˜æ›´ç±»ä¼¼äº 77 é¢˜ï¼ŒåŒºåˆ«åœ¨äº

1. 77 é¢˜çš„æ•°å­—èŒƒå›´ n æ›´å¤§ [1,20]ï¼Œè€Œæœ¬é¢˜æ•°å­—èŒƒå›´é™åˆ¶ä¸º [1,9]
2. æœ¬é¢˜ä¸ä»…ä»…æ‰¾åˆ°ç»„åˆï¼Œè¿˜è¦è®©ç»„åˆä¹‹å’Œç­‰äº targetï¼ˆç±»ä¼¼äº 39 é¢˜ï¼‰

å‰ªæä¼˜åŒ–

1. å¦‚æœå‰©ä½™çš„å’Œ target è¿˜æ²¡ i å¤§ï¼Œè¿™æ—¶å‡å®Œ i æ˜¯è´Ÿæ•°ï¼Œè‚¯å®šæ— æ³•æ»¡è¶³è¦æ±‚ï¼Œå› æ­¤æœ‰å‰ªææ¡ä»¶ï¼š
   * `target < i`
2. å¦‚æœç»„åˆçš„æ•°å­—ä¸ªæ•°å·²ç»åˆ°è¾¾äº†ä¸Šé™ kï¼Œè¿˜æ²¡æœ‰å‡‘å¤Ÿ targetï¼Œä¹Ÿæ²¡å¿…è¦ç»§ç»­é€’å½’ï¼Œå› æ­¤æœ‰ï¼š
   - `stack.size() == k`

### 8) N çš‡å Leetcode 51

```java
public class NQueenLeetcode51 {
    static List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        char[][] table = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(table[i], '.');
        }
        dfs(0, n, table, result);
        return result;
    }

    static void dfs(int i, int n, char[][] table, List<List<String>> result) {
        if (i == n) {
            ArrayList<String> list = new ArrayList<>();
            for (char[] chars : table) {
                list.add(String.valueOf(chars));
            }
            result.add(list);
            return;
        }
        for (int j = 0; j < n; j++) {
            if (notValid(table, i, j)) {
                continue;
            }
            table[i][j] = 'Q';
            dfs(i + 1, n, table, result);
            table[i][j] = '.';
        }
    }
    /*
        .   .   .   .
        .   .   .   .
        .   ?   .   .
        .   .   .   .
     */

    static boolean notValid(char[][] table, int row, int col) {
        int n = table.length;
        for (int i = 0; i < n; i++) {
            if (table[i][col] == 'Q') { // ä¸Š
                return true;
            }
        }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (table[i][j] == 'Q') {
                return true;
            }
        }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (table[i][j] == 'Q') {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        int count = 0;
        for (List<String> table : solveNQueens(8)) {
            for (String row : table) {
                System.out.println(row);
            }
            count++;
            System.out.println("--------------------- " + count);
        }
    }
}
```

```java
public class NQueenLeetcode51 {
    static List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        char[][] table = new char[n][n];
        boolean[] va = new boolean[n];
        boolean[] vb = new boolean[2 * n - 1];
        boolean[] vc = new boolean[2 * n - 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(table[i], '.');
        }
        dfs(0, n, table, result, va, vb, vc);
        return result;
    }

    static void dfs(int i, int n, char[][] table, List<List<String>> result, boolean[] va, boolean[] vb, boolean[] vc) {
        if (i == n) {
            ArrayList<String> list = new ArrayList<>();
            for (char[] chars : table) {
                list.add(String.valueOf(chars));
            }
            result.add(list);
            return;
        }
        for (int j = 0; j < n; j++) {
            if (va[j] || vb[i + j] || vc[i - j + n - 1]) {
                continue;
            }
            va[j] = true;
            vb[i + j] = true;
            vc[i - j + n - 1] = true;
            table[i][j] = 'Q';
            dfs(i + 1, n, table, result, va, vb, vc);
            table[i][j] = '.';
            va[j] = false;
            vb[i + j] = false;
            vc[i - j + n - 1] = false;
        }
    }

    public static void main(String[] args) {
        int count = 0;
        for (List<String> table : solveNQueens(4)) {
            for (String row : table) {
                System.out.println(row);
            }
            count++;
            System.out.println("--------------------- " + count);
        }
    }
}
```

### 9) è§£æ•°ç‹¬-Leetcode37

```java
public class SudokuLeetcode37 {
    record Pair(int i, int j) {

    }

    static void solveSudoku(char[][] table) {
        int n = 9;
        boolean[][] va = new boolean[n][n];
        boolean[][] vb = new boolean[n][n];
        boolean[][][] vc = new boolean[3][3][n];
        List<Pair> blanks = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (table[i][j] != '.') {
                    int x = table[i][j] - '0' - 1;
                    va[i][x] = true;
                    vb[j][x] = true;
                    vc[i / 3][j / 3][x] = true;
                } else {
                    blanks.add(new Pair(i, j));
                }
            }
        }
        dfs(0, blanks, table, va, vb, vc);
    }

    static boolean dfs(int p, List<Pair> blanks, char[][] table, boolean[][] va, boolean[][] vb, boolean[][][] vc) {
        if (p == blanks.size()) {
            print(table);
            return true;
        }
        int n = table.length;
        for (int d = 0; d < n; d++) {
            Pair pair = blanks.get(p);
            if (va[pair.i][d] || vb[pair.j][d] || vc[pair.i / 3][pair.j / 3][d]) {
                continue;
            }
            char ch = (char) (d + '0' + 1);
            table[pair.i][pair.j] = ch;
            va[pair.i][d] = true;
            vb[pair.j][d] = true;
            vc[pair.i / 3][pair.j / 3][d] = true;
            boolean dfs = dfs(p + 1, blanks, table, va, vb, vc);
            if (dfs) {
                return true;
            }
            table[pair.i][pair.j] = '.';
            va[pair.i][d] = false;
            vb[pair.j][d] = false;
            vc[pair.i / 3][pair.j / 3][d] = false;

        }
        return false;
    }

    public static void main(String[] args) {
        char[][] table = {
                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
        };

        solveSudoku(table);

        print(table);
    }

    static char[][] solved = {
            {'5', '3', '4', '6', '7', '8', '9', '1', '2'},
            {'6', '7', '2', '1', '9', '5', '3', '4', '8'},
            {'1', '9', '8', '3', '4', '2', '5', '6', '7'},
            {'8', '5', '9', '7', '6', '1', '4', '2', '3'},
            {'4', '2', '6', '8', '5', '3', '7', '9', '1'},
            {'7', '1', '3', '9', '2', '4', '8', '5', '6'},
            {'9', '6', '1', '5', '3', '7', '2', '8', '4'},
            {'2', '8', '7', '4', '1', '9', '6', '3', '5'},
            {'3', '4', '5', '2', '8', '6', '1', '7', '9'}
    };

    static void print(char[][] table) {
        for (char[] chars : table) {
            System.out.println(new String(chars));
        }
        System.out.println(Arrays.deepEquals(table, solved));
    }
}
```

```java
public class SudokuLeetcode37 {

    static void solveSudoku(char[][] table) {
        int n = 9;
        boolean[][] va = new boolean[n][n];
        boolean[][] vb = new boolean[n][n];
        boolean[][][] vc = new boolean[3][3][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (table[i][j] != '.') {
                    int x = table[i][j] - '0' - 1;
                    va[i][x] = true;
                    vb[j][x] = true;
                    vc[i / 3][j / 3][x] = true;
                }
            }
        }
        dfs(table, va, vb, vc, 0, 0);
    }

    static boolean dfs(char[][] table, boolean[][] va, boolean[][] vb, boolean[][][] vc, int i, int j) {
        while (table[i][j] != '.') {
            if (++j >= 9) {
                j = 0;
                i++;
            }
            if (i >= 9) {
                return true;
            }
        }
        int n = table.length;
        for (int d = 0; d < n; d++) {
            if (va[i][d] || vb[j][d] || vc[i / 3][j / 3][d]) {
                continue;
            }
            char ch = (char) (d + '0' + 1);
            table[i][j] = ch;
            va[i][d] = true;
            vb[j][d] = true;
            vc[i / 3][j / 3][d] = true;
            boolean dfs = dfs(table, va, vb, vc, i, j);
            if (dfs) {
                return true;
            }
            table[i][j] = '.';
            va[i][d] = false;
            vb[j][d] = false;
            vc[i / 3][j / 3][d] = false;

        }
        return false;
    }

    public static void main(String[] args) {
        char[][] table = {
                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
        };
        solveSudoku(table);

        print(table);
    }

    static char[][] solved = {
            {'5', '3', '4', '6', '7', '8', '9', '1', '2'},
            {'6', '7', '2', '1', '9', '5', '3', '4', '8'},
            {'1', '9', '8', '3', '4', '2', '5', '6', '7'},
            {'8', '5', '9', '7', '6', '1', '4', '2', '3'},
            {'4', '2', '6', '8', '5', '3', '7', '9', '1'},
            {'7', '1', '3', '9', '2', '4', '8', '5', '6'},
            {'9', '6', '1', '5', '3', '7', '2', '8', '4'},
            {'2', '8', '7', '4', '1', '9', '6', '3', '5'},
            {'3', '4', '5', '2', '8', '6', '1', '7', '9'}
    };

    static void print(char[][] table) {
        for (char[] chars : table) {
            System.out.println(new String(chars));
        }
        System.out.println(Arrays.deepEquals(table, solved));
    }
}
```

### å…¶å®ƒé¢˜ç›®

| é¢˜å·          | æ ‡é¢˜                                   | è¯´æ˜                                                                                    |
| ------------- | -------------------------------------- | --------------------------------------------------------------------------------------- |
| Leetcode 1219 | é»„é‡‘çŸ¿å·¥                               |                                                                                         |
| æ—             | é©¬è¸æ£‹ç›˜ï¼ˆThe Knightâ€™s tour problemï¼‰ |                                                                                         |
| æ—             | Rat in a Maze                          | ä¸ Leetcode 62 ä¸åŒè·¯å¾„åŒºåˆ«åœ¨äºï¼Œè¯¥é¢˜é—®çš„æ˜¯æœ‰å¤šå°‘ç§èµ°æ³•ï¼Œè€Œæœ¬é¢˜åªæ˜¯æ‰¾åˆ°å…¶ä¸­ä¸€ç§èµ°æ³•å®ç° |

## 4.6 Leetcode åŒæŒ‡é’ˆ

ä¸‹é¢æ˜¯çš„é¢˜ç›®éƒ½ä¼šæ¶‰åŠåŒæŒ‡é’ˆï¼Œé™¤æ­¤å¤–ï¼Œè¿˜æœ‰

* Leetcode3 æœ€é•¿ä¸é‡å¤å­ä¸²ï¼Œåœ¨ hash è¡¨éƒ¨åˆ†è®²è¿‡äº†
* å¿«æ’ä¸­
* äºŒåˆ†ä¸­
* ...

### ç§»åŠ¨é›¶-Leetcode 283

```java
public class MoveZeroesLeetcode283 {
    static void moveZeroes(int[] nums) {
        int i = 0;
        int j = 0;
        while (j < nums.length) {
            if (nums[j] != 0) {
                int t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
                i++;
            }
            j++;
        }
    }

    public static void main(String[] args) {
        int[] nums = {0, 1, 0, 3, 12};
        moveZeroes(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

### ä¸¤æ•°ä¹‹å’Œ II-Leetcode 167

```java
public class SumLeetcode167 {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(twoSum(new int[]{2, 7, 11, 15}, 9)));
    }
    static public int[] twoSum(int[] numbers, int target) {
        return twoSum(numbers, 0, numbers.length - 1, target);
    }
    static int[] twoSum(int[] nums, int left, int right, int target) {
        int i = left;
        int j = right;
        while (i < j) {
            if (nums[i] + nums[j] < target) {
                i++;
            } else if (nums[i] + nums[j] > target) {
                j--;
            } else {
                break;
            }
        }
        return new int[]{i + 1, j + 1};
    }
}
```

ä¸ Leetcode 1 çš„ä¸¤æ•°ä¹‹å’ŒåŒºåˆ«åœ¨äºï¼Œæœ¬é¢˜çš„æ•°ç»„æ˜¯å‡åºæ’å¥½çš„

### ä¸‰æ•°ä¹‹å’Œ-Leetcode 15

```java
public class SumLeetcode15 {

    static List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new LinkedList<>();
        dfs(3, 0, nums.length - 1, 0, nums,
                new LinkedList<>(), result);
        return result;
    }

    static void dfs(int n, int i, int j, int target, int[] nums,
                    LinkedList<Integer> stack,
                    List<List<Integer>> result) {
        if (n == 2) {
            // å¥—ç”¨ä¸¤æ•°ä¹‹å’Œæ±‚è§£
            twoSum(i, j, nums, target, stack, result);
            return;
        }
        for (int k = i; k < j - (n - 2); k++) {
            // æ£€æŸ¥é‡å¤
            if (k > i && nums[k] == nums[k - 1]) {
                continue;
            }
            // å›ºå®šä¸€ä¸ªæ•°å­—ï¼Œå†å°è¯• n-1 æ•°å­—ä¹‹å’Œ
            stack.push(nums[k]);
            dfs(n - 1, k + 1, j, target - nums[k], nums, stack, result);
            stack.pop();
        }
    }

    static int count;

    static public void twoSum(int i, int j, int[] numbers, int target,
                              LinkedList<Integer> stack,
                              List<List<Integer>> result) {
        count++;
        while (i < j) {
            int sum = numbers[i] + numbers[j];
            if (sum < target) {
                i++;
            } else if (sum > target) {
                j--;
            } else { // æ‰¾åˆ°è§£
                ArrayList<Integer> list = new ArrayList<>(stack);
                list.add(numbers[i]);
                list.add(numbers[j]);
                result.add(list);
                // ç»§ç»­æŸ¥æ‰¾å…¶å®ƒçš„è§£
                i++;
                j--;
                while (i < j && numbers[i] == numbers[i - 1]) {
                    i++;
                }
                while (i < j && numbers[j] == numbers[j + 1]) {
                    j--;
                }
            }
        }
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        int[] candidates = {-4, -1, -1, 0, 0, 1, 1, 2};
        System.out.println("æ•°æ®é‡:" + candidates.length);
        System.out.println(threeSum(candidates));
        System.out.println("è€—è´¹æ—¶é—´:" + (System.currentTimeMillis() - start));
        System.out.println("é€’å½’æ¬¡æ•°:" + count);
    }
}
```

* æœ¬é¢˜ä¸ä¹‹å‰çš„ä¸¤æ•°ä¹‹å’Œï¼ˆLeetcode 1 å’Œ Leetcode 167ï¼‰ç›¸æ¯”ï¼ŒåŒºåˆ«åœ¨äº
  * ä¸¤æ•°ä¹‹å’Œé‡Œæ˜ç¡®è¯´äº†ï¼Œåªæœ‰ä¸€ä¸ªç­”æ¡ˆï¼Œè€Œæœ¬é¢˜è¦æ‰¾å‡ºæ‰€æœ‰ç­”æ¡ˆ
  * æœ¬é¢˜è¦è€ƒè™‘å»é‡
* æœ¬é¢˜ç±»ä¼¼äº ç»„åˆæ€»å’Œ IIï¼ˆLeetcode 40ï¼‰ åŒºåˆ«åœ¨äº
  * 40 é¢˜è¦æ±‚åˆ—å‡ºä»»æ„æ•°ä¹‹å’Œç­‰äº target çš„æ‰€æœ‰ç»„åˆï¼Œè€Œæœ¬é¢˜è¦æ±‚ä¸‰æ•°ä¹‹å’Œç­‰äº target çš„æ‰€æœ‰ç»„åˆ
  * 40 é¢˜ä½¿ç”¨å›æº¯çš„åŠæ³•æ—¶é—´å¤æ‚åº¦æ˜¯ $O(2^n * n)$ï¼Œè€Œæœ¬é¢˜çš„ä¸‰æ•°é™åˆ¶äº†é€’å½’æ¬¡æ•°ä»…æœ‰ä¸€æ¬¡ï¼Œå¹¶ä¸”æ¯æ¬¡é€’å½’ç»ˆç‚¹æ˜¯æ±‚ä¸¤æ•°ä¹‹å’Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$
* å°ä¼˜åŒ–ï¼šå›ºå®šæ•°å­—æ—¶ï¼Œåº”è¯¥é¢„ç•™ä¸‰ä¸ªæ•°å­—åšä¸‰æ•°ä¹‹å’Œï¼Œé¢„è§ˆä¸¤ä¸ªæ•°å­—åšä¸¤æ•°ä¹‹å’Œï¼Œå› æ­¤æœ‰ k < j - (n - 2)

### å››æ•°ä¹‹å’Œ-Leetcode 18

```java
public class SumLeetcode18 {

    static List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> result = new LinkedList<>();
        dfs(4, 0, nums.length - 1, target, nums,
                new LinkedList<>(), result);
        return result;
    }

    static void dfs(int n, int i, int j, int target, int[] nums,
                    LinkedList<Integer> stack,
                    List<List<Integer>> result) {
        if (n == 2) {
            // å¥—ç”¨ä¸¤æ•°ä¹‹å’Œæ±‚è§£
            twoSum(i, j, nums, target, stack, result);
            return;
        }
        for (int k = i; k < j - (n - 2); k++) { // å››æ•°ä¹‹å’Œ i <j-2  ä¸‰æ•°ä¹‹å’Œ i <j-1
            // æ£€æŸ¥é‡å¤
            if (k > i && nums[k] == nums[k - 1]) {
                continue;
            }
            // å›ºå®šä¸€ä¸ªæ•°å­—ï¼Œå†å°è¯• n-1 æ•°å­—ä¹‹å’Œ
            stack.push(nums[k]);
            dfs(n - 1, k + 1, j, target - nums[k], nums, stack, result);
            stack.pop();
        }
    }

    static int count;

    static public void twoSum(int i, int j, int[] numbers, int target,
                              LinkedList<Integer> stack,
                              List<List<Integer>> result) {
        count++;
        while (i < j) {
            int sum = numbers[i] + numbers[j];
            if (sum < target) {
                i++;
            } else if (sum > target) {
                j--;
            } else { // æ‰¾åˆ°è§£
                ArrayList<Integer> list = new ArrayList<>(stack);
                list.add(numbers[i]);
                list.add(numbers[j]);
                result.add(list);
                // ç»§ç»­æŸ¥æ‰¾å…¶å®ƒçš„è§£
                i++;
                j--;
                while (i < j && numbers[i] == numbers[i - 1]) {
                    i++;
                }
                while (i < j && numbers[j] == numbers[j + 1]) {
                    j--;
                }
            }
        }
    }

    public static void main(String[] args) {
        System.out.println(fourSum(new int[]{1, 0, -1, 0, -2, 2}, 0));
//        System.out.println(fourSum(new int[]{2, 2, 2, 2, 2}, 8));
//        System.out.println(fourSum(new int[]{1000000000,1000000000,1000000000,1000000000}, -294967296));
    }
}
```

### ç››æœ€å¤šæ°´çš„å®¹å™¨-Leetcode 11

```java
public class MostWaterLeetcode11 {
    static int maxArea(int[] height) {
        int i = 0;
        int j = height.length - 1;
        int max = 0;
        while (i < j) {
            int min = Integer.min(height[i], height[j]);
            max = Integer.max(max, (j - i) * min);
            while (i < j && height[i] <= min) {
                i++;
            }
            while (i < j && height[j] <= min) {
                j--;
            }
        }
        return max;
    }

    public static void main(String[] args) {
        System.out.println(maxArea(new int[]{1, 8, 6, 2, 5, 4, 8, 3, 7})); // 49
        System.out.println(maxArea(new int[]{2,1})); // 1
    }
}
```

### åè½¬å­—ç¬¦æ•°ç»„-Leetcode 344

åŒæŒ‡é’ˆ

```java
public class ReverseStringLeetcode344 {
    public static void main(String[] args) {
        char[] array = "abcde".toCharArray();
        reverseString(array);
        System.out.println(Arrays.toString(array));
    }

    static void reverseString(char[] s) {
        recursion(s, 0, s.length - 1);
    }

    public static void recursion(char[] array, int i, int j) {
        if (i >= j) {
            return;
        }
        swap(array, i, j);
        recursion(array, ++i, --j);
    }

    public static void swap(char[] array, int i, int j) {
        char c = array[i];
        array[i] = array[j];
        array[j] = c;
    }
}
```

* ç¬¬ä¸€æ¬¡äº¤æ¢çš„æ˜¯ array[0] å’Œ array[4]
* ç¬¬äºŒæ¬¡äº¤æ¢çš„æ˜¯ array[1] å’Œ array[3]
* ç¬¬ä¸‰æ¬¡ i = j = 2ï¼Œå¼€å§‹è¿”å›
* å¦‚æœ array.length æ˜¯å¶æ•°ï¼Œåˆ™ä¼šåœ¨ i > j æ—¶è¿”å›

## 4.7 Leetcode å•è°ƒé˜Ÿåˆ—å’Œæ ˆ

### å•è°ƒé€’å‡é˜Ÿåˆ—

```java
public class MonotonicStack<T extends Comparable<T>> {
    private final LinkedList<T> stack = new LinkedList<>();

    public void push(T t) {
        while (!stack.isEmpty() && stack.peek().compareTo(t) < 0) {
            stack.pop();
        }
        stack.push(t);
    }

    public void pop() {
        stack.pop();
    }

    public T peek() {
        return stack.peek();
    }

    @Override
    public String toString() {
        return stack.toString();
    }

    public static void main(String[] args) {
        MonotonicStack<Integer> stack = new MonotonicStack<>();
        for (int i : new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}) {
            stack.push(i);
            System.out.println(stack);
        }
    }
}
```

### æœ€å¤§æ»‘åŠ¨çª—å£-Leetcode 239

```java
public class SlidingWindowMaximumLeetcode239 {
    static int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue<Integer> q = new MonotonicQueue<>();
        int[] output = new int[nums.length - (k - 1)];
        for (int i = 0; i < nums.length; i++) {
            if (i >= k && nums[i - k] == q.peek()) {
                q.poll();
            }
            int num = nums[i];
            q.offer(num);
            if (i >= k - 1) {
                output[i - (k - 1)] = q.peek();
            }
        }
        return output;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(maxSlidingWindow(new int[]{1, 3, -1, -3, 5, 3, 6, 7}, 3))); //[3, 3, 5, 5, 6, 7]
        System.out.println(Arrays.toString(maxSlidingWindow(new int[]{7, 2, 4}, 2))); // [7, 4]
        System.out.println(Arrays.toString(maxSlidingWindow(new int[]{1, 3, 1, 2, 0, 5}, 3))); // [3, 3, 2, 5]
        System.out.println(Arrays.toString(maxSlidingWindow(new int[]{-7, -8, 7, 5, 7, 1, 6, 0}, 4))); // [7, 7, 7, 7, 7]
    }
}
```

* å¦‚æœæ¯ç§»åŠ¨ä¸€æ¬¡çª—å£ï¼Œå°±åœ¨ k ä¸ªæ•°é‡Œæ‰¾æœ€å¤§å€¼ï¼Œæ—¶é—´å¤æ‚åº¦çº¦ä¸º $O(n*k)$
* åˆ©ç”¨äº†å•è°ƒé˜Ÿåˆ—åï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ€å¤š**å…¥é˜Ÿ**ã€**å‡ºé˜Ÿ**ä¸€æ¬¡ï¼Œæ‰¾æœ€å¤§å€¼å°±åœ¨é˜Ÿå¤´æ‰¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$

### å•è°ƒé€’å‡æ ˆ

```java
public class MonotonicStack {
    static class ValueAndIndex {
        int value;
        int i;

        public ValueAndIndex(int value, int i) {
            this.value = value;
            this.i = i;
        }

        @Override
        public String toString() {
//            return "[%d]%d".formatted(index, value);
            return "%d".formatted(value);
        }
    }

    private final LinkedList<ValueAndIndex> stack = new LinkedList<>();

    public void push(int value, int i, TriConsumer onPop) {
        while (!stack.isEmpty() && stack.peek().value < value) {
            ValueAndIndex pop = stack.pop();
            ValueAndIndex peek = stack.peek();
            if (peek != null) {
                onPop.accept(pop.value, peek.value, peek.i);
            }
        }
        stack.push(new ValueAndIndex(value, i));
    }

    @Override
    public String toString() {
        return stack.toString();
    }
}
```

### æ¥é›¨æ°´-Leetcode 42

```java
public class TrappingRainWaterLeetcode42 {
    public static void main(String[] args) {
        System.out.println(trap(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1})); // 6
        System.out.println(trap(new int[]{4, 2, 0, 3, 2, 5})); // 9
    }

    record Data(int height, int i) {
    }


    static int trap(int[] heights) {
        int sum = 0;
        LinkedList<Data> stack = new LinkedList<>();
        for (int i = 0; i < heights.length; i++) {
            Data right = new Data(heights[i], i);
            while (!stack.isEmpty() && stack.peek().height < heights[i]) {
                Data pop = stack.pop();
                Data left = stack.peek();
                if (left != null) {
                    sum += (Integer.min(left.height, right.height) - pop.height) * (right.i - left.i - 1);
                }
            }
            stack.push(right);
        }
        return sum;
    }
}
```

* ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆ
* å½“åŠ å…¥æ–°æŸ±å­ï¼ˆrightï¼‰æ—¶ï¼Œå¦‚æœå‘ç°è¦å¼¹å‡ºä¹‹å‰çš„æŸ±å­ï¼Œè¡¨ç¤ºé‡åˆ°äº†å‡¹é™·çš„åœ°æ–¹
  * æ­¤æ—¶æ ˆé‡Œæ²¡æœ‰æ›´å·¦è¾¹çš„æŸ±å­ï¼Œè¡¨ç¤ºæ‹¦ä¸ä½é›¨æ°´
  * æ ˆé‡Œæœ‰å·¦è¾¹æŸ±å­ï¼ˆleftï¼‰å°±å¯ä»¥è®¡ç®—é›¨æ°´å®¹é‡ï¼š$(right.i - left.i-1)*Min(right.height,left.height)-pop.height$

## 4.8 Leetcode å­—ç¬¦ä¸²

### indexOf-Leetcode 28

native string matching

```java
public class StrStrLeetcode28 {
    static int strStr(String haystack, String needle) {
        char[] text = haystack.toCharArray();
        char[] pattern = needle.toCharArray();
        int n = text.length;
        int m = pattern.length;
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (pattern[j] != text[i + j]) {
                    break;
                }
            }
            if (j == m) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        System.out.println(strStr("aaacaaab", "aaab"));
    }
}
```

kmp string matching

```java
public class StrStrLeetcode28KMP {
    static int strStr(String haystack, String needle) {
        char[] text = haystack.toCharArray();
        char[] pattern = needle.toCharArray();
        int n = text.length;
        int m = pattern.length;
        int[] lps = lps(pattern);
        int i = 0;
        int j = 0;
        while ((n - i) >= (m - j)) {
            if (text[i] == pattern[j]) { // åŒ¹é…æˆåŠŸ
                i++;
                j++;
            } else if (j != 0) { // åŒ¹é…å¤±è´¥
                j = lsp[j - 1];
            } else { // åŒ¹é…å¤±è´¥ j == 0
                i++;
            }
            if (j == m) { // æ‰¾åˆ°è§£
                return i - j;
            }
        }
        return -1;
    }

    static int[] lps(char[] pattern) {
        int[] lps = new int[pattern.length];
        int i = 1; // åç¼€
        int j = 0; // å‰ç¼€ åŒæ—¶ä¹Ÿæ˜¯æ•°é‡
        while (i < pattern.length) {
            if (pattern[i] == pattern[j]) {
                j++;
                lps[i] = j;
                i++;
            } else if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
        return lps;
    }

    public static void main(String[] args) {
        System.out.println(strStr("aaaaaaab", "aaab"));
//        System.out.println(Arrays.toString(prefix("aaab".toCharArray())));
        System.out.println(Arrays.toString(lsp("ababaca".toCharArray())));

    }
}
```

* å¾ˆå¤šæ–‡ç« é‡Œ[^17]ï¼ŒæŠŠ lps æ•°ç»„çš„å‘åå¹³ç§»ä¸€ä½ï¼Œlps ç”¨ -1 å¡«å……ï¼Œè¿™ä¸ªå¹³ç§»åçš„æ•°ç»„ç§°ä¸º next
  * è¿™æ ·å¯ä»¥ç”¨ -1 ä»£æ›¿ j == 0 çš„åˆ¤æ–­
  * å¹¶å¯ä»¥åœ¨ j > 0 å‘å‰ç§»åŠ¨æ—¶ï¼Œåšå°‘é‡ä¼˜åŒ–ï¼ˆä¸ç”¨ next æ•°ç»„ä¹Ÿèƒ½åšåŒæ ·ä¼˜åŒ–ï¼‰
* å…¶å®ƒå­—ç¬¦ä¸²åŒ¹é…ç®—æ³•æœ‰ï¼šBM ç®—æ³•ã€sunday ç®—æ³•ã€Horspool ç®—æ³•ç­‰

### æœ€é•¿å…¬å…±å‰ç¼€-Leetcode 14

```java
public class LCPLeetcode14 {
    static String longestCommonPrefix(String[] strings) {
        char[] first = strings[0].toCharArray();
        for (int i = 0; i < first.length; i++) {
            char ch = first[i];
            for (int j = 1; j < strings.length; j++) {
                if (i == strings[j].length() || ch != strings[j].charAt(i)) {
                    return new String(first, 0, i);
                }
            }
        }
        return strings[0];
    }

    public static void main(String[] args) {
        System.out.println(longestCommonPrefix(new String[]{"flower", "flow", "flight"})); // fl
        System.out.println(longestCommonPrefix(new String[]{"dog","racecar","car"})); //
        System.out.println(longestCommonPrefix(new String[]{"ab","a"})); // a
        System.out.println(longestCommonPrefix(new String[]{"dog","dogaa","dogbb"})); // dog
    }
}
```

### æœ€é•¿å›æ–‡å­ä¸²-Leetcode 5

```java
public class LongestPalindromeLeetcode5 {
    public static void main(String[] args) {
        System.out.println(longestPalindrome("babad"));  // bab
        System.out.println(longestPalindrome("cbbd"));	 // bb
        System.out.println(longestPalindrome("a"));		 // a
    }

    record Result(int i, int length) {
        static Result max(Result r1, Result r2, Result r3) {
            Result m = r1;
            if (r2.length > m.length) {
                m = r2;
            }
            if (r3.length > m.length) {
                m = r3;
            }
            return m;
        }
    }

    static String longestPalindrome(String s) {
        char[] chars = s.toCharArray();
        Result max = new Result(0, 1);
        for (int i = 0; i < chars.length - 1; i++) {
            Result r1 = extend(chars, i, i);
            Result r2 = extend(chars, i, i + 1);
            max = Result.max(max, r1, r2);
        }
        return new String(chars, max.i, max.length);
    }

    private static Result extend(char[] chars, int i, int j) {
        int len = chars.length;
        while (i >= 0 && j < len && chars[i] == chars[j]) {
            i--;
            j++;
        }
        i++;
        return new Result(i, j - i);
    }
}
```

* è¿˜æœ‰æ—¶é—´å¤æ‚åº¦æ›´ä½çš„ç®—æ³•ï¼šManacher

### æœ€å°è¦†ç›–å­ä¸²-Leetcode 76

```java
public class MinWindowLeetcode76_2 {
    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC")); // BANC
        System.out.println(minWindow("aaabbbbbcdd", "abcdd")); // abbbbbcdd
    }

    record Answer(int count, int i, int j) {

    }

    static String minWindow(String s, String t) {
        char[] source = s.toCharArray();
        char[] target = t.toCharArray();
        int[] targetCountMap = new int[128];
        int[] windowCountMap = new int[128];
        for (char ch : target) {
            targetCountMap[ch]++;
        }
        int i = 0;
        int j = 0;
        Answer answer = new Answer(Integer.MAX_VALUE, i, j);
        int passCount = 0;
        for (int count : targetCountMap) {
            if (count > 0) {
                passCount++;
            }
        }
        int pass = 0;
        while (j < source.length) {
            char right = source[j];
            int c = ++windowCountMap[right];
            if (c == targetCountMap[right]) {
                pass++;
            }
            while (pass == passCount && i <= j) {
                if (j - i < answer.count) {
                    answer = new Answer(j - i, i, j);
                }
                char left = source[i];
                windowCountMap[left]--;
                if (windowCountMap[left] < targetCountMap[left]) {
                    pass--;
                }
                i++;
            }
            j++;
        }

        return answer.count != Integer.MAX_VALUE ? s.substring(answer.i, answer.j + 1) : "";
    }
}
```

## 4.9 Leetcode è®¾è®¡

### LRU ç¼“å­˜-Leetcode 146

```java
public class LRUCacheLeetcode146 {

    static class LRUCache {
        static class Node {
            Node prev;
            Node next;
            int key;
            int value;

            public Node(int key, int value) {
                this.key = key;
                this.value = value;
            }
        }

        static class DoublyLinkedList {
            private final Node head;
            private final Node tail;

            DoublyLinkedList() {
                head = tail = new Node(-1, -1);
                head.next = tail;
                tail.prev = head;
            }

            void addFirst(Node newFirst) {
                Node oldFirst = head.next;
                newFirst.prev = head;
                newFirst.next = oldFirst;
                head.next = newFirst;
                oldFirst.prev = newFirst;
            }

            void remove(Node node) {
                Node prev = node.prev;
                Node next = node.next;
                prev.next = next;
                next.prev = prev;
            }

            Node removeLast() {
                Node last = tail.prev;
                remove(last);
                return last;
            }
        }

        private final HashMap<Integer, Node> map = new HashMap<>();
        private final DoublyLinkedList linkedList = new DoublyLinkedList();
        private final int capacity;

        public LRUCache(int capacity) {
            this.capacity = capacity;
        }

        public int get(int key) {
            Node node = map.get(key);
            if (node == null) {
                return -1;
            }
            linkedList.remove(node);
            linkedList.addFirst(node);
            return node.value;
        }

        public void put(int key, int value) {
            if (map.containsKey(key)) {
                Node node = map.get(key);
                node.value = value;
                linkedList.remove(node);
                linkedList.addFirst(node);
            } else {
                Node node = new Node(key, value);
                map.put(key, node);
                linkedList.addFirst(node);
                if (map.size() > capacity) {
                    Node last = linkedList.removeLast();
                    map.remove(last.key);
                }
            }
        }
    }

    public static void main(String[] args) {
        LRUCache cache = new LRUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        System.out.println(cache.get(1)); // 1
        cache.put(3, 3);
        System.out.println(cache.get(2)); // -1
        cache.put(4, 4);
        System.out.println(cache.get(1)); // -1
        System.out.println(cache.get(3)); // 3
    }
}
```

æ³¨æ„ï¼š

* è¿™é‡Œå¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯ï¼Œmap ä¸­å­˜å‚¨ nodeï¼Œå¯ä»¥çœå»åœ¨åŒå‘é“¾è¡¨ä¸­æŸ¥æ‰¾ node çš„æ—¶é—´ï¼Œè¿™æ ·è®©ä½¿ç”¨æœ€è¿‘è®¿é—®çš„èŠ‚ç‚¹ç§»åŠ¨åˆ°é“¾è¡¨å¤´æ—¶è¾¾åˆ° $O(1)$ çš„éœ€æ±‚
* åŒæ—¶æˆ‘ä»¬åº”å½“æ„è¯†åˆ°ï¼Œnode çš„å¼•ç”¨ä¸èƒ½ä¿®æ”¹äº†ï¼ˆä¸æ–¹ä¾¿ä¿®æ”¹ï¼ŒçœŸè¦æ”¹å¾—åŒæ—¶æ”¹é“¾è¡¨ï¼‰
  * ä¾‹å¦‚ï¼Œä¸èƒ½åœ¨æ›´æ–°æ—¶ç”¨æ–°çš„ node å¯¹è±¡æ›¿æ¢ï¼Œè€Œåº”è¯¥åœ¨åŸæœ‰çš„ node ä¸Šä¿®æ”¹ value

### LFU ç¼“å­˜-Leetcode 460

```java
public class LFUCacheLeetcode460 {
    static class LFUCache {
        static class Node {
            Node prev;
            Node next;
            int key;
            int value;
            int freq;

            public Node() {
            }

            public Node(int key, int value, int freq) {
                this.key = key;
                this.value = value;
                this.freq = freq;
            }
        }

        static class DoublyLinkedList {
            private final Node head;
            private final Node tail;
            int size = 0;

            public DoublyLinkedList() {
                head = tail = new Node();
                head.next = tail;
                tail.prev = head;
            }

            void remove(Node node) {
                Node prev = node.prev;
                Node next = node.next;
                prev.next = next;
                next.prev = prev;
                node.prev = node.next = null;
                size--;
            }

            void addFirst(Node newFirst) {
                Node oldFirst = head.next;
                newFirst.prev = head;
                newFirst.next = oldFirst;
                head.next = newFirst;
                oldFirst.prev = newFirst;
                size++;
            }

            Node removeLast() {
                Node last = tail.prev;
                remove(last);
                return last;
            }

            boolean isEmpty() {
                return size == 0;
            }
        }

        private final HashMap<Integer, DoublyLinkedList> freqMap = new HashMap<>();
        private final HashMap<Integer, Node> kvMap = new HashMap<>();

        private final int capacity;
        private int minFreq;

        public LFUCache(int capacity) {
            this.capacity = capacity;
        }

        public int get(int key) {
            Node node = kvMap.get(key);
            if (node == null) {
                return -1;
            }
            DoublyLinkedList list = freqMap.get(node.freq);
            list.remove(node);
            if (node.freq == minFreq && list.isEmpty()) {
                minFreq++;
            }
            node.freq++;
            freqMap.computeIfAbsent(node.freq, k -> new DoublyLinkedList()).addFirst(node);
            return node.value;
        }

        public void put(int key, int value) {
            if (kvMap.containsKey(key)) {
                Node node = kvMap.get(key);
                DoublyLinkedList list = freqMap.get(node.freq);
                list.remove(node);
                if (node.freq == minFreq && list.isEmpty()) {
                    minFreq++;
                }
                node.freq++;
                node.value = value;
                freqMap.computeIfAbsent(node.freq, k -> new DoublyLinkedList()).addFirst(node);
            } else {
                if (kvMap.size() == capacity) {
                    Node last = freqMap.get(minFreq).removeLast();
                    kvMap.remove(last.key);
                }
                Node node = new Node(key, value, 1);
                kvMap.put(key, node);
                minFreq = 1;
                freqMap.computeIfAbsent(node.freq, k -> new DoublyLinkedList()).addFirst(node);
            }
        }
    }

    public static void main(String[] args) {
        LFUCache cache = new LFUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        System.out.println(cache.get(1)); // 1 freq=2
        cache.put(3, 3);
        System.out.println(cache.get(2)); // -1
        System.out.println(cache.get(3)); // 3 freq=2
        cache.put(4, 4);
        System.out.println(cache.get(1)); // -1
        System.out.println(cache.get(3)); // 3  freq=3
        System.out.println(cache.get(4)); // 4  freq=2

    }
}
```

### éšæœºæ•°

#### çº¿æ€§åŒä½™å‘ç”Ÿå™¨

å…¬å¼ $nextSeed = (seed * a + c) \mod m$

```java
public class MyRandom {
    private final int a;
    private final int c;
    private final int m;
    private int seed;

    public MyRandom(int a, int c, int m, int seed) {
        this.a = a;
        this.c = c;
        this.m = m;
        this.seed = seed;
    }

    public int nextInt() {
        return seed = (a * seed + c) % m;
    }

    public static void main(String[] args) {
        MyRandom r1 = new MyRandom(7, 0, 11, 1);
        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(30).toArray()));
        MyRandom r2 = new MyRandom(7, 0, Integer.MAX_VALUE, 1);
        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(30).toArray()));
    }
}
```

* 32 ä½éšæœºæ•°ç”Ÿæˆå™¨
* ä¹˜æ³•ä¼šè¶…è¿‡ int èŒƒå›´å¯¼è‡´éšæœºæ€§è¢«ç ´å

#### java ç‰ˆ

```java
public class MyRandom2 {
    private static final long a = 0x5DEECE66DL;
    private static final long c = 0xBL;
    private static final long m = 1L << 48;

    private long seed;

    public MyRandom2(long seed) {
        this.seed = (seed ^ a) & (m - 1);
    }

    public int nextInt() {
        seed = (a * seed + c) & (m - 1);
        return ((int) (seed >>> 16));
    }

    public static void main(String[] args) {
        Random r1 = new Random(1);
        MyRandom2 r2 = new MyRandom2(1);
        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(10).toArray()));
        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(10).toArray()));
    }
}
```

* 0x5DEECE66DL * 0x5DEECE66DL ä¸ä¼šè¶…è¿‡ long çš„èŒƒå›´
* m å†³å®šåªå– 48 ä½éšæœºæ•°
* å¯¹äº nextIntï¼Œåªå– 48 ä½éšæœºæ•°çš„é«˜ 32 ä½

### è·³è¡¨-Leetcode 1206

#### randomLevel

è®¾è®¡ä¸€ä¸ªæ–¹æ³•è°ƒç”¨è‹¥å¹²æ¬¡ï¼Œæ¯æ¬¡è¿”å› *1~max* çš„æ•°å­—ï¼Œä» 1 å¼€å§‹ï¼Œè¿”å›æ•°å­—çš„æ¯”ä¾‹å‡åŠï¼Œä¾‹å¦‚ *max = 4*ï¼Œè®©å¤§æ¦‚

* 50% çš„å‡ ç‡è¿”å› 1
* 25% çš„å‡ ç‡è¿”å› 2
* 12.5% çš„å‡ ç‡è¿”å› 3
* 12.5% çš„å‡ ç‡è¿”å› 4

```java
/*
    ç¬¬ä¸€è½®æœ‰ 500 ä¸ª(level 1) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 500 ä¸ª(level 2)
    ç¬¬äºŒè½®æœ‰ 250 ä¸ª(level 2) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 125 ä¸ª(level 3)
    ç¬¬ä¸‰è½®æœ‰ 63 ä¸ª(level 3) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 62 ä¸ª(level 4) ç”±äºç¬¬äºŒä¸ªæ¡ä»¶é€€å‡ºå¾ªç¯
 */
static int randomLevel(int max) {
    int level = 1;
    while (Math.random() < 0.5 && level < max) {
        level++;
    }  
    return level;
}
```

#### è·³è¡¨

```java
public class SkipListLeetcode1206 {


    public static void main(String[] args) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < 1000; i++) {
            int level = Skiplist.randomLevel();
            map.compute(level, (k, v) -> v == null ? 1 : v + 1);
        }
        System.out.println(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> String.format("%d%%", e.getValue() * 100 / 1000))));
    }


    static class Skiplist {
        static final int MAX = 4;

        static int randomLevel() {
            int level = 1;
            while (Math.random() < 0.5 && level < MAX) {
                level++;
            }
        /*
            ç¬¬ä¸€è½®æœ‰ 500 ä¸ª(level 1) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 500 ä¸ª(level 2)
            ç¬¬äºŒè½®æœ‰ 250 ä¸ª(level 2) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 125 ä¸ª(level 3)
            ç¬¬ä¸‰è½®æœ‰ 63 ä¸ª(level 3) >= 0.5 é€€å‡ºå¾ªç¯ï¼Œå‰©ä¸‹ 62 ä¸ª(level 4) ç”±äºç¬¬äºŒä¸ªæ¡ä»¶é€€å‡ºå¾ªç¯
         */
            return level;
        }

        private final Node head = new Node(-1);

        static class Node {
            int val;
            Node[] next;

            public Node(int val) {
                this.val = val;
                this.next = new Node[MAX];
            }
        }

        private Node[] find(int val) {
            Node[] path = new Node[MAX];
            Node curr = head;
            for (int lvl = MAX - 1; lvl >= 0; lvl--) {
                while (curr.next[lvl] != null && curr.next[lvl].val < val) {
                    curr = curr.next[lvl];
                }
                path[lvl] = curr;
            }
            return path;
        }

        public boolean search(int val) {
            Node[] path = find(val);
            Node node = path[0].next[0];
            return node != null && node.val == val;
        }

        public void add(int val) {
            Node[] path = find(val);
            int lv = randomLevel();
            Node node = new Node(val);
            for (int i = 0; i < lv; i++) {
                node.next[i] = path[i].next[i];
                path[i].next[i] = node;
            }
        }

        public boolean erase(int val) {
            Node[] path = find(val);
            Node node = path[0].next[0];
            if (node == null || node.val != val) {
                return false;
            }
            for (int i = 0; i < MAX; i++) {
                if (path[i].next[i] != node) {
                    break;
                }
                path[i].next[i] = node.next[i];
            }
            return true;
        }
    }
}
```

ä¸‹æ¥¼æ¢¯è§„åˆ™

- è‹¥ next æŒ‡é’ˆä¸º nullï¼Œæˆ–è€… next æŒ‡å‘çš„èŠ‚ç‚¹å€¼ >= ç›®æ ‡ï¼Œå‘ä¸‹æ‰¾
- è‹¥ next æŒ‡é’ˆä¸ä¸º nullï¼Œä¸” next æŒ‡å‘çš„èŠ‚ç‚¹å€¼ < ç›®æ ‡ï¼Œå‘å³æ‰¾

èŠ‚ç‚¹çš„ã€é«˜åº¦ã€‘

* é«˜åº¦å¹¶ä¸éœ€è¦é¢å¤–å±æ€§æ¥è®°å½•ï¼Œè€Œæ˜¯ç”±ä¹‹å‰èŠ‚ç‚¹ next == æœ¬èŠ‚ç‚¹çš„ä¸ªæ•°æ¥å†³å®šï¼Œæˆ–æ˜¯æœ¬èŠ‚ç‚¹ next æ•°ç»„é•¿åº¦
* æœ¬å®ç°é€‰æ‹©äº†ç¬¬ä¸€ç§æ–¹å¼æ¥å†³å®šé«˜åº¦ï¼Œæœ¬èŠ‚ç‚¹çš„ next æ•°ç»„é•¿åº¦ç»Ÿä¸€ä¸º MAX

### æœ€å°æ ˆ-Leetcode 155

è§£æ³•1

```java
static class MinStack {
    LinkedList<Integer> stack = new LinkedList<>();
    LinkedList<Integer> min = new LinkedList<>();

    public MinStack() {
        min.push(Integer.MAX_VALUE);
    }

    public void push(int val) {
        stack.push(val);
        min.push(Math.min(val, min.peek()));
    }

    public void pop() {
        if (stack.isEmpty()) {
            return;
        }
        stack.pop();
        min.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return min.peek();
    }
}
```

è§£æ³•2

```java
static class MinStack2 {
    record Data(int val, int min) {

    }
    final LinkedList<Data> stack = new LinkedList<>();

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new Data(val, val));
        } else {
            Data peek = stack.peek();
            stack.push(new Data(val, Math.min(val, peek.min)));
        }
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek().val;
    }

    public int getMin() {
        return stack.peek().min;
    }
}
```

### TinyURL çš„åŠ å¯†ä¸è§£å¯†-Leetcode 535

```java
public class TinyURLLeetcode535 {

    public static void main(String[] args) {
        /*CodecSequence codec = new CodecSequence();
        String encoded = codec.encode("https://leetcode.cn/problems/1");
        System.out.println(encoded);

        encoded = codec.encode("https://leetcode.cn/problems/2");
        System.out.println(encoded);*/
//        for (int i = 0; i <= 62; i++) {
//            System.out.println(i + "\t" + CodecSequence.toBase62(i));
//        }

        System.out.println(CodecSequence.toBase62(237849728));
    }


    /*
        è¦è®©ã€é•¿ã€‘ã€çŸ­ã€‘ç½‘å€ä¸€ä¸€å¯¹åº”

            1. ç”¨ã€éšæœºæ•°ã€‘ä½œä¸ºçŸ­ç½‘å€æ ‡è¯†
            2. ç”¨ã€hashç ã€‘ä½œä¸ºçŸ­ç½‘å€æ ‡è¯†
            3. ç”¨ã€é€’å¢æ•°ã€‘ä½œä¸ºçŸ­ç½‘å€æ ‡è¯†
                1) å¤šçº¿ç¨‹ä¸‹å¯ä»¥ä½¿ç”¨å—ï¼Ÿ
                2) åˆ†å¸ƒå¼ä¸‹å¯ä»¥ä½¿ç”¨å—ï¼Ÿ
                3) 4e9iAk æ˜¯æ€ä¹ˆç”Ÿæˆçš„ï¼Ÿ

                a-z 0-9 A-Z  62è¿›åˆ¶çš„æ•°å­—

        0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f

        åè¿›åˆ¶ => åå…­è¿›åˆ¶
        31       1f

        31 % 16 = 15
        31 / 16 = 1

        1 % 16 = 1
        1 / 16 = 0


        é•¿ç½‘å€ï¼š https://leetcode.cn/problems/encode-and-decode-tinyurl/description/
        å¯¹åº”çš„çŸ­ç½‘å€ï¼š http://tinyurl.com/4e9iAk
     */

    static class CodecSequence {
        private static final char[] toBase62 = {
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
        };

        public static String toBase62(int number) {
            if (number == 0) {
                return String.valueOf(toBase62[0]);
            }
            StringBuilder sb = new StringBuilder();
            while (number > 0) {
                int r = number % 62;
                sb.append(toBase62[r]);
                number = number / 62;
            }
            return sb.toString();
        }

        private final Map<String, String> longToShort = new HashMap<>();
        private final Map<String, String> shortToLong = new HashMap<>();
        private static final String SHORT_PREFIX = "http://tinyurl.com/";
        private static int id = 1;

        public String encode(String longUrl) {
            String shortUrl = longToShort.get(longUrl);
            if (shortUrl != null) {
                return shortUrl;
            }
            // ç”ŸæˆçŸ­ç½‘å€
            shortUrl = SHORT_PREFIX + id;
            longToShort.put(longUrl, shortUrl);
            shortToLong.put(shortUrl, longUrl);
            id++;
            return shortUrl;
        }

        public String decode(String shortUrl) {
            return shortToLong.get(shortUrl);
        }
    }

    static class CodecHashCode {
        private final Map<String, String> longToShort = new HashMap<>();
        private final Map<String, String> shortToLong = new HashMap<>();
        private static final String SHORT_PREFIX = "http://tinyurl.com/";

        public String encode(String longUrl) {
            String shortUrl = longToShort.get(longUrl);
            if (shortUrl != null) {
                return shortUrl;
            }
            // ç”ŸæˆçŸ­ç½‘å€
            int id = longUrl.hashCode(); // int
            while (true) {
                shortUrl = SHORT_PREFIX + id;
                if (!shortToLong.containsKey(shortUrl)) {
                    longToShort.put(longUrl, shortUrl);
                    shortToLong.put(shortUrl, longUrl);
                    break;
                }
                id++;
            }
            return shortUrl;
        }

        public String decode(String shortUrl) {
            return shortToLong.get(shortUrl);
        }
    }

    static class CodecRandom {
        private final Map<String, String> longToShort = new HashMap<>();
        private final Map<String, String> shortToLong = new HashMap<>();
        private static final String SHORT_PREFIX = "http://tinyurl.com/";

        public String encode(String longUrl) {
            String shortUrl = longToShort.get(longUrl);
            if (shortUrl != null) {
                return shortUrl;
            }
            // ç”ŸæˆçŸ­ç½‘å€
            while (true) {
                int id = ThreadLocalRandom.current().nextInt();// 1
                shortUrl = SHORT_PREFIX + id;
                if (!shortToLong.containsKey(shortUrl)) {
                    longToShort.put(longUrl, shortUrl);
                    shortToLong.put(shortUrl, longUrl);
                    break;
                }
            }
            return shortUrl;
        }

        public String decode(String shortUrl) {
            return shortToLong.get(shortUrl);
        }
    }
}
```

### è®¾è®¡ Twitter-Leetcode 355

çº¿æ€§åˆå¹¶

```java
static class Twitter2 {

    static int time;

    static class Tweet {
        int id;
        int time;
        Tweet next;

        public Tweet(int id, int time, Tweet next) {
            this.id = id;
            this.time = time;
            this.next = next;
        }

        public int id() {
            return id;
        }

        public int time() {
            return time;
        }
    }

    static class User {
        Integer id;

        public User(Integer id) {
            this.id = id;
        }

        Set<Integer> followees = new HashSet<>();
        Tweet head = new Tweet(-1, -1, null);
    }

    private final Map<Integer, User> userMap = new HashMap<Integer, User>();

    public void postTweet(int userId, int tweetId) {
        User user = userMap.computeIfAbsent(userId, User::new);
        user.head.next = new Tweet(tweetId, time++, user.head.next);
    }

    public List<Integer> getNewsFeed(int userId) {
        User user = userMap.get(userId);
        if (user == null) {
            return List.of();
        }
        Tweet p1 = user.head.next;
        for (Integer id : user.followees) {
            p1 = merge(p1, userMap.get(id).head.next);
        }
        LinkedList<Integer> result = new LinkedList<>();
        int count = 0;
        while (p1 != null && count < 10) {
            result.addLast(p1.id);
            p1 = p1.next;
            count++;
        }
        return result;
    }

    private Tweet merge(Tweet p1, Tweet p2) {
        Tweet head = new Tweet(-1, -1, null);
        Tweet p0 = head;
        int count = 0;
        while (p1 != null && p2 != null && count < 10) {
            if (p1.time > p2.time) {
                p0.next = new Tweet(p1.id, p1.time, null);
                p0 = p0.next;
                p1 = p1.next;
            } else {
                p0.next = new Tweet(p2.id, p2.time, null);
                p0 = p0.next;
                p2 = p2.next;
            }
            count++;
        }
        while (p1 != null && count < 10) {
            p0.next = new Tweet(p1.id, p1.time, null);
            p0 = p0.next;
            p1 = p1.next;
            count++;
        }
        while (p2 != null && count < 10) {
            p0.next = new Tweet(p2.id, p2.time, null);
            p0 = p0.next;
            p2 = p2.next;
            count++;
        }
        return head.next;
    }

    public void follow(int userId, int followeeId) {
        User user = userMap.computeIfAbsent(userId, User::new);
        User followee = userMap.computeIfAbsent(followeeId, User::new);
        user.followees.add(followeeId);
    }

    public void unfollow(int userId, int followeeId) {
        User user = userMap.get(userId);
        if (user != null) {
            user.followees.remove(followeeId);
        }
    }
}
```

ä¼˜å…ˆçº§é˜Ÿåˆ—åˆå¹¶

```java
public class TwitterLeetcode355 {
    static class Twitter {

        static class Tweet {
            int id;
            int time;
            Tweet next;

            public Tweet(int id, int time, Tweet next) {
                this.id = id;
                this.time = time;
                this.next = next;
            }

            public int getId() {
                return id;
            }

            public int getTime() {
                return time;
            }
        }

        static class User {
            int id;

            public User(int id) {
                this.id = id;
            }

            Set<Integer> followees = new HashSet<>();
            Tweet head = new Tweet(-1, -1, null);
        }

        private final Map<Integer, User> userMap = new HashMap<>();
        private static int time;

        // å‘å¸ƒæ–‡ç« 
        public void postTweet(int userId, int tweetId) {
            User user = userMap.computeIfAbsent(userId, User::new);
            user.head.next = new Tweet(tweetId, time++, user.head.next);
        }

        // æ–°å¢å…³æ³¨
        public void follow(int userId, int followeeId) {
            User user = userMap.computeIfAbsent(userId, User::new);
            User followee = userMap.computeIfAbsent(followeeId, User::new);
            user.followees.add(followee.id);
        }

        // å–æ¶ˆå…³æ³¨
        public void unfollow(int userId, int followeeId) {
            User user = userMap.get(userId);
            if (user != null) {
                user.followees.remove(followeeId);
            }
        }

        // è·å–æœ€æ–°10ç¯‡æ–‡ç« ï¼ˆåŒ…æ‹¬è‡ªå·±å’Œå…³æ³¨ç”¨æˆ·ï¼‰
        public List<Integer> getNewsFeed(int userId) {
            User user = userMap.get(userId);
            if (user == null) {
                return List.of();
            }
            PriorityQueue<Tweet> queue
                    = new PriorityQueue<>(Comparator.comparingInt(Tweet::getTime).reversed());
            if(user.head.next != null) {
                queue.offer(user.head.next);
            }
            for (Integer id : user.followees) {
                User followee = userMap.get(id);
                if(followee.head.next != null) {
                    queue.offer(followee.head.next);
                }
            }
            List<Integer> res = new ArrayList<>();
            int count = 0;
            while (!queue.isEmpty() && count < 10) {
                Tweet max = queue.poll();
                res.add(max.id);
                if (max.next != null) {
                    queue.offer(max.next);
                }
                count++;
            }
            return res;
        }
    }
}
```

## 4.10 è‚¡ç¥¨é—®é¢˜

### Leetcode 121

```java
public class SharesI {
    static int maxProfit(int[] prices) {
        int i = 0;
        int j = 1;
        int max = 0;
        while (j < prices.length) {
            if (prices[j] - prices[i] > 0) {
                max = Math.max(max, prices[j] - prices[i]);
                j++;
            } else {
                i = j;
                j++;
            }
        }
        return max;
    }

    public static void main(String[] args) {
        System.out.println(maxProfit(new int[]{9, 3, 12, 1, 2, 3, 11}));
    }
}
```

### Leetcode 122

```java
public class SharesIILeetcode122 {
    static int maxProfit(int[] prices) {
        int i = 0;
        int j = 1;
        int max = 0;
        while (j < prices.length) {
            if (prices[j] - prices[i] > 0) { // æœ‰åˆ©æ¶¦
                max += prices[j] - prices[i];
            }
            i = j;
            j++;
        }
        return max;
    }

    public static void main(String[] args) {
        System.out.println(maxProfit(new int[]{9, 3, 12, 1, 2, 3})); // 11
        System.out.println(maxProfit(new int[]{7, 1, 5, 3, 6, 4})); // 7
    }
}
```

### Leetcode 714

```java
public class SharesLeetcode714 {
    /*
        0       1           2           3           4       5
        1       3           2           8           4       9
 ä¹°     -1     ç­‰-1 âˆš       ç­‰-1 âˆš       ç­‰-1 âˆš      -1       ç­‰1 âˆš
               ä¹°-3         ä¹°-2        ä¹°-8        ä¹°1 âˆš     ä¹°-4
 å–     0      ç­‰0  âˆš        ç­‰0  âˆš      ç­‰0          ç­‰5 âˆš    ç­‰5
               å–0          å–-1         å–5 âˆš        å–1     å–8 âˆš


     */
    static int maxProfit(int[] prices, int fee) {
        int b1 = -prices[0];
        int s1 = 0;
        for (int i = 1; i < prices.length; i++) {
            int s0 = Math.max(s1, b1 + prices[i] - fee);
            int b0 = Math.max(b1, s1 - prices[i]);
            s1 = s0;
            b1 = b0;
        }
        return s1;
    }

    public static void main(String[] args) {
        System.out.println(maxProfit(new int[]{1, 3, 2, 8, 4, 9}, 2)); // 8
        System.out.println(maxProfit(new int[]{1, 3, 7, 2, 18, 3}, 3)); // 16
//
        System.out.println(maxProfit(new int[]{1, 3, 7, 5, 10, 3}, 3)); // 6
        System.out.println(maxProfit(new int[]{1, 3, 7, 5, 10, 11, 3}, 3)); // 7
        System.out.println(maxProfit(new int[]{2,1,4,4,2,3,2,5,1,2}, 1)); // 4
    }
}
```

é™ç»´

```java
static int maxProfit(int[] prices, int fee) {
    // _buy _sell ä»£è¡¨ä¸Šä¸€æ¬¡ buy sell ä»£è¡¨è¿™ä¸€æ¬¡
    int _buy = -prices[0];
    int _sell = 0;
    for (int i = 1; i < prices.length; i++) {
        int buy = Math.max(_buy, _sell - prices[i]);
        int sell = Math.max(_sell, _buy + prices[i] - fee);
        _buy = buy;
        _sell = sell;
    }
    return _sell;
}
```

ç»“æ„ä¼˜åŒ–ï¼ˆéæ€§èƒ½ï¼‰

```java
static int maxProfit(int[] prices, int fee) {
    int buy = Integer.MIN_VALUE;
    int sell = 0;
    for (int price : prices) {
        buy = Math.max(buy, sell - price);
        /*
            è‹¥ max æ˜¯ ä¸Šæ¬¡ buyï¼Œé‚£ä¹ˆæ˜¾ç„¶ç”¨è¿™æ¬¡ buy æ˜¯ä¸€æ ·çš„
            è‹¥ max æ˜¯ ä¸Šæ¬¡ sell - prices[i], åˆ™
                Math.max(sell, sell - prices[i] + prices[i] - fee);
                ==>
                Math.max(sell, sell - fee);
                æ˜¾ç„¶åé¢çš„å¼å­ä¸å¯èƒ½æ¯”ä¸Šæ¬¡ sell æ›´å¤§ï¼Œæ­¤æ—¶æ–°çš„ sell åªç”±ä¸Šæ¬¡ sell å†³å®šï¼Œä¸ ä¸Šæ¬¡ buy æ— å…³
         */
        sell = Math.max(sell, buy + price - fee);
    }
    return sell;
}
```

1. åœ¨è®¡ç®—è¿™æ¬¡çš„ sell æ—¶ï¼Œç”¨è¿™æ¬¡çš„ buy ä»£æ›¿ä¸Šæ¬¡ buyï¼ˆè¯æ˜è§ä¸Šæ–¹æ³¨é‡Šï¼‰
2. è®¾ç½® buy çš„åˆå§‹å€¼ä¸ºæœ€å°ï¼Œå¯ä»¥è®©å¾ªç¯ç»Ÿä¸€ä» 0 å¼€å§‹

### Leetcode 309

```java
public class SharesLeetcode309 {
    /*
        0       1           2           3           4
        1       2           3           0           2
 ä¹°     -1      -2          -3          1âˆš          0
 ç­‰             -1âˆš         -1âˆš         -1          1âˆš
 å–     0       1âˆš          2âˆš          -1          3âˆš
 ç­‰             0           1           2âˆš          2

     */
    static int maxProfit(int[] prices) {
        if (prices.length == 1) {
            return 0;
        }
        int[] buy = new int[prices.length];
        int[] sell = new int[prices.length];
        buy[0] = -prices[0];
        sell[0] = 0;
        buy[1] = Math.max(-prices[0], -prices[1]);
        sell[1] = Math.max(sell[0], buy[0] + prices[1]);
        for (int i = 2; i < prices.length; i++) {
            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
        }
        return sell[prices.length - 1];
    }

    public static void main(String[] args) {
        System.out.println(maxProfit(new int[]{1, 2, 3, 0, 2})); // 3
    }
}
```

é™ç»´

```java
static int maxProfit(int[] prices) {
    if (prices.length == 1) {
        return 0;
    }
    int __sell = 0;
    int _sell = 0;
    int _buy = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        int buy = Math.max(_buy, __sell - prices[i]);
        int sell = Math.max(_sell, prices[i] + _buy);
        _buy = buy;
        __sell = _sell;
        _sell = sell;
    }
    return _sell;
}
```

### Leetcode 123

```java
public class SharesIIILeetcode123 {
    static int maxProfit(int[] prices) {
        int buy1 = Integer.MIN_VALUE;
        int sell1 = 0;
        int buy2 = Integer.MIN_VALUE;
        int sell2 = 0;
        for (int price : prices) {
            buy1 = Math.max(buy1, -price);
            sell1 = Math.max(sell1, buy1 + price);
            buy2 = Math.max(buy2, sell1 - price);
            sell2 = Math.max(sell2, buy2 + price);
        }
        return sell2;
    }

    public static void main(String[] args) {
        System.out.println(maxProfit(new int[]{3, 3, 5, 0, 0, 3, 1, 4})); // 6
    }
}
```

### Leetcode 188

```java
public class SharesLeetcode188 {
    static int maxProfit(int[] prices) {
        int i = 0;
        int j = 1;
        int sum = 0;
        while (j < prices.length) {
            if (prices[j] - prices[i] > 0) { // æœ‰åˆ©æ¶¦
                sum += prices[j] - prices[i];
            }
            i++;
            j++;
        }
        return sum;
    }

    static int maxProfit(int k, int[] prices) {
        if (k > prices.length / 2) {
            return maxProfit(prices);
        }
        int[] buy = new int[k];
        int[] sell = new int[k];
        Arrays.fill(buy, Integer.MIN_VALUE);
        for (int price : prices) {
            buy[0] = Math.max(buy[0], -price);
            sell[0] = Math.max(sell[0], buy[0] + price);
            for (int j = 1; j < k; j++) {
                buy[j] = Math.max(buy[j], sell[j - 1] - price);
                sell[j] = Math.max(sell[j], buy[j] + price);
            }
        }
        return sell[k - 1];
    }

    public static void main(String[] args) {
//        System.out.println(maxProfit(2, new int[]{3, 2, 6, 5, 0, 3})); // 7
        System.out.println(maxProfit(2, new int[]{3, 3, 5, 0, 0, 3, 1, 4})); // 6
    }
}
```

* å¯¹äºå¤©æ•° n = 6ï¼Œæœ€å¤šè¿›è¡Œ 3 æ¬¡äº¤æ˜“ï¼Œå¦‚æœæ­¤æ—¶ k > 3ï¼Œæ„å‘³ç€ä¸é™æ¬¡äº¤æ˜“
* å¯¹äºå¤©æ•° n = 7ï¼Œæœ€å¤šè¿›è¡Œ 3 æ¬¡äº¤æ˜“ï¼Œå¦‚æœæ­¤æ—¶ k > 3ï¼Œæ„å‘³ç€ä¸é™æ¬¡äº¤æ˜“

# é™„å½•

## å‚è€ƒæ–‡ç« 

## æ¨èå›¾ä¹¦

### å…¥é—¨å›¾ä¹¦

![](./imgs/s29358625.jpg)

### ç³»ç»Ÿå­¦ä¹ 

![](./imgs/s29460367.jpg)

![](./imgs/s29107491.jpg)

### æ‰©å±•é˜…è¯»

<img src="./imgs/s29205454.jpg"  />

<img src="./imgs/s29970325.jpg"  />

![](./imgs/s33662490.jpg)

![](./imgs/s34606338.jpg)

### é¢è¯•

![](./imgs/s34075059.jpg)

### æ¡ˆå¤´è£… B

<img src="./imgs/s25648004.jpg"  />

![](./imgs/s11706681.jpg)

> åæ§½
>
> - è‹±æ–‡ç‰ˆå°é¢è®¾è®¡æœ¬æ¥æŒºå¥½çœ‹çš„ï¼Œæœºå·¥éè¦å¥—ä¸ªé»‘å£³å­

## åŠ›æ‰£é«˜è¯„ä»·é¢˜ç›®åˆ—è¡¨

å¼•ç”¨è‡ª [é¢è¯•æœ€å¸¸è€ƒçš„ 100 é“ç®—æ³•é¢˜åˆ†ç±»æ•´ç†ï¼ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/449686402)

> å¸¦ âœ”ï¸ æ˜¯æœ¬è¯¾ç¨‹è®²è§£è¿‡çš„

- **[1. Two Sum (ä¸¤æ•°ä¹‹å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/two-sum/)**, Easy, 11757 likes âœ”ï¸
- **[2. Add Two Numbers (ä¸¤æ•°ç›¸åŠ )](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/add-two-numbers/)**, Medium, 6524 likes âœ”ï¸
- **[3. Longest Substring Without Repeating Characters (æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-substring-without-repeating-characters/)**, Medium, 5845 likes âœ”ï¸
- **[4. Median of Two Sorted Arrays (å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/median-of-two-sorted-arrays/)**, Hard, 4303 likes
- **[5. Longest Palindromic Substring (æœ€é•¿å›æ–‡å­ä¸²)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-palindromic-substring/)**, Medium, 3896 likes âœ”ï¸
- **[15. 3Sum (ä¸‰æ•°ä¹‹å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/3sum/)**, Medium, 3582 likes âœ”ï¸
- **[53. Maximum Subarray (æœ€å¤§å­åºå’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-subarray/)**, Easy, 3533 likes
- **[7. Reverse Integer (æ•´æ•°åè½¬)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-integer/)**, Easy, 2970 likes
- **[11. Container With Most Water (ç››æœ€å¤šæ°´çš„å®¹å™¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/container-with-most-water/)**, Medium, 2659 likes âœ”ï¸
- **[42. Trapping Rain Water (æ¥é›¨æ°´)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/trapping-rain-water/)**, Hard, 2552 likes âœ”ï¸
- **[20. Valid Parentheses (æœ‰æ•ˆçš„æ‹¬å·)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-parentheses/)**, Easy, 2544 likes âœ”ï¸
- **[10. Regular Expression Matching (æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/regular-expression-matching/)**, Hard, 2273 likes
- **[26. Remove Duplicates from Sorted Array (åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)**, Easy, 2146 likes âœ”ï¸
- **[136. Single Number (åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/single-number/)**, Easy, 1958 likes âœ”ï¸
- **[22. Generate Parentheses (æ‹¬å·ç”Ÿæˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/generate-parentheses/)**, Medium, 1946 likes âœ”ï¸
- **[206. Reverse Linked List (åè½¬é“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-linked-list/)**, Easy, 1886 likes âœ”ï¸
- **[21. Merge Two Sorted Lists (åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-two-sorted-lists/)**, Easy, 1832 likes âœ”ï¸
- **[70. Climbing Stairs (çˆ¬æ¥¼æ¢¯)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/climbing-stairs/)**, Easy, 1791 likes âœ”ï¸
- **[300. Longest Increasing Subsequence (æœ€é•¿é€’å¢å­åºåˆ—)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-increasing-subsequence/)**, Medium, 1773 likes âœ”ï¸
- **[121. Best Time to Buy and Sell Stock (ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)**, Easy, 1766 likes âœ”ï¸
- **[72. Edit Distance (ç¼–è¾‘è·ç¦»)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/edit-distance/)**, Hard, 1743 likes
- **[14. Longest Common Prefix (æœ€é•¿å…¬å…±å‰ç¼€)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-common-prefix/)**, Easy, 1707 likes âœ”ï¸
- **[198. House Robber (æ‰“å®¶åŠ«èˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/house-robber/)**, Medium, 1585 likes âœ”ï¸
- **[9. Palindrome Number (å›æ–‡æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/palindrome-number/)**, Easy, 1568 likes
- **[146. LRU Cache (LRU ç¼“å­˜æœºåˆ¶)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lru-cache/)**, Medium, 1544 likes âœ”ï¸
- **[19. Remove Nth Node From End of List (åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**, Medium, 1494 likes âœ”ï¸
- **[33. Search in Rotated Sorted Array (æœç´¢æ—‹è½¬æ’åºæ•°ç»„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/search-in-rotated-sorted-array/)**, Medium, 1493 likes
- **[46. Permutations (å…¨æ’åˆ—)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/permutations/)**, Medium, 1484 likes âœ”ï¸
- **[101. Symmetric Tree (å¯¹ç§°äºŒå‰æ ‘)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/symmetric-tree/)**, Easy, 1483 likes âœ”ï¸
- **[84. Largest Rectangle in Histogram (æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/largest-rectangle-in-histogram/)**, Hard, 1472 likes
- **[39. Combination Sum (ç»„åˆæ€»å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/combination-sum/)**, Medium, 1466 likes âœ”ï¸
- **[13. Roman to Integer (ç½—é©¬æ•°å­—è½¬æ•´æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/roman-to-integer/)**, Easy, 1436 likes
- **[23. Merge k Sorted Lists (åˆå¹¶Kä¸ªå‡åºé“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-k-sorted-lists/)**, Hard, 1436 likes âœ”ï¸
- **[17. Letter Combinations of a Phone Number (ç”µè¯å·ç çš„å­—æ¯ç»„åˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)**, Medium, 1436 likes
- **[322. Coin Change (é›¶é’±å…‘æ¢)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/coin-change/)**, Medium, 1414 likes âœ”ï¸
- **[32. Longest Valid Parentheses (æœ€é•¿æœ‰æ•ˆæ‹¬å·)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-valid-parentheses/)**, Hard, 1400 likes
- **[287. Find the Duplicate Number (å¯»æ‰¾é‡å¤æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-the-duplicate-number/)**, Medium, 1325 likes
- **[122. Best Time to Buy and Sell Stock II (ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)**, Easy, 1306 likes âœ”ï¸
- **[160. Intersection of Two Linked Lists (ç›¸äº¤é“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/intersection-of-two-linked-lists/)**, Easy, 1302 likes âœ”ï¸
- **[55. Jump Game (è·³è·ƒæ¸¸æˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/jump-game/)**, Medium, 1292 likes
- **[76. Minimum Window Substring (æœ€å°è¦†ç›–å­ä¸²)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/minimum-window-substring/)**, Hard, 1280 likes âœ”ï¸
- **[200. Number of Islands (å²›å±¿æ•°é‡)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/number-of-islands/)**, Medium, 1270 likes
- **[78. Subsets (å­é›†)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/subsets/)**, Medium, 1269 likes
- **[31. Next Permutation (ä¸‹ä¸€ä¸ªæ’åˆ—)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/next-permutation/)**, Medium, 1260 likes
- **[96. Unique Binary Search Trees (ä¸åŒçš„äºŒå‰æœç´¢æ ‘)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/unique-binary-search-trees/)**, Medium, 1257 likes âœ”ï¸
- **[148. Sort List (æ’åºé“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sort-list/)**, Medium, 1248 likes
- **[236. Lowest Common Ancestor of a Binary Tree (äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)**, Medium, 1238 likes âœ”ï¸
- **[25. Reverse Nodes in k-Group (K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-nodes-in-k-group/)**, Hard, 1230 likes
- **[6. ZigZag Conversion (Z å­—å½¢å˜æ¢)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/zigzag-conversion/)**, Medium, 1226 likes
- **[152. Maximum Product Subarray (ä¹˜ç§¯æœ€å¤§å­æ•°ç»„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-product-subarray/)**, Medium, 1223 likes
- **[215. Kth Largest Element in an Array (æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ )](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/kth-largest-element-in-an-array/)**, Medium, 1211 likes âœ”ï¸
- **[8. String to Integer (atoi) (å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi))](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/string-to-integer-atoi/)**, Medium, 1168 likes
- **[41. First Missing Positive (ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/first-missing-positive/)**, Hard, 1163 likes
- **[283. Move Zeroes (ç§»åŠ¨é›¶)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/move-zeroes/)**, Easy, 1162 likes âœ”ï¸
- **[141. Linked List Cycle (ç¯å½¢é“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/linked-list-cycle/)**, Easy, 1161 likes âœ”ï¸
- **[98. Validate Binary Search Tree (éªŒè¯äºŒå‰æœç´¢æ ‘)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/validate-binary-search-tree/)**, Medium, 1156 likes âœ”ï¸
- **[124. Binary Tree Maximum Path Sum (äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-maximum-path-sum/)**, Hard, 1152 likes
- **[105. Construct Binary Tree from Preorder and Inorder Traversal (ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)**, Medium, 1149 likes âœ”ï¸
- **[34. Find First and Last Position of Element in Sorted Array (åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)**, Medium, 1137 likes âœ”ï¸
- **[239. Sliding Window Maximum (æ»‘åŠ¨çª—å£æœ€å¤§å€¼)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sliding-window-maximum/)**, Hard, 1114 likes âœ”ï¸
- **[142. Linked List Cycle II (ç¯å½¢é“¾è¡¨ II)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/linked-list-cycle-ii/)**, Medium, 1097 likes âœ”ï¸
- **[139. Word Break (å•è¯æ‹†åˆ†)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-break/)**, Medium, 1097 likes
- **[45. Jump Game II (è·³è·ƒæ¸¸æˆ II)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/jump-game-ii/)**, Medium, 1094 likes
- **[169. Majority Element (å¤šæ•°å…ƒç´ )](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/majority-element/)**, Easy, 1089 likes
- **[234. Palindrome Linked List (å›æ–‡é“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/palindrome-linked-list/)**, Easy, 1072 likes âœ”ï¸
- **[62. Unique Paths (ä¸åŒè·¯å¾„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/unique-paths/)**, Medium, 1072 likes âœ”ï¸
- **[189. Rotate Array (æ—‹è½¬æ•°ç»„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/rotate-array/)**, Medium, 1057 likes
- **[94. Binary Tree Inorder Traversal (äºŒå‰æ ‘çš„ä¸­åºéå†)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-inorder-traversal/)**, Easy, 1052 likes âœ”ï¸
- **[56. Merge Intervals (åˆå¹¶åŒºé—´)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-intervals/)**, Medium, 1051 likes
- **[88. Merge Sorted Array (åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-sorted-array/)**, Easy, 1041 likes âœ”ï¸
- **[560. Subarray Sum Equals K (å’Œä¸ºKçš„å­æ•°ç»„)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/subarray-sum-equals-k/)**, Medium, 1036 likes
- **[279. Perfect Squares (å®Œå…¨å¹³æ–¹æ•°)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/perfect-squares/)**, Medium, 1035 likes
- **[35. Search Insert Position (æœç´¢æ’å…¥ä½ç½®)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/search-insert-position/)**, Easy, 1005 likes âœ”ï¸
- **[24. Swap Nodes in Pairs (ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/swap-nodes-in-pairs/)**, Medium, 996 likes
- **[85. Maximal Rectangle (æœ€å¤§çŸ©å½¢)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximal-rectangle/)**, Hard, 983 likes
- **[28. Implement strStr() (å®ç° strStr())](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/implement-strstr/)**, Easy, 982 likes âœ”ï¸
- **[92. Reverse Linked List II (åè½¬é“¾è¡¨ II)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-linked-list-ii/)**, Medium, 980 likes
- **[155. Min Stack (æœ€å°æ ˆ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/min-stack/)**, Easy, 979 likes âœ”ï¸
- **[79. Word Search (å•è¯æœç´¢)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-search/)**, Medium, 979 likes
- **[27. Remove Element (ç§»é™¤å…ƒç´ )](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-element/)**, Easy, 967 likes
- **[51. N-Queens (N çš‡å)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/n-queens/)**, Hard, 965 likes âœ”ï¸
- **[75. Sort Colors (é¢œè‰²åˆ†ç±»)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sort-colors/)**, Medium, 961 likes
- **[102. Binary Tree Level Order Traversal (äºŒå‰æ ‘çš„å±‚åºéå†)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-level-order-traversal/)**, Medium, 960 likes âœ”ï¸
- **[48. Rotate Image (æ—‹è½¬å›¾åƒ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/rotate-image/)**, Medium, 960 likes
- **[95. Unique Binary Search Trees II (ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/unique-binary-search-trees-ii/)**, Medium, 955 likes
- **[64. Minimum Path Sum (æœ€å°è·¯å¾„å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/minimum-path-sum/)**, Medium, 954 likes
- **[406. Queue Reconstruction by Height (æ ¹æ®èº«é«˜é‡å»ºé˜Ÿåˆ—)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/queue-reconstruction-by-height/)**, Medium, 947 likes
- **[226. Invert Binary Tree (ç¿»è½¬äºŒå‰æ ‘)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/invert-binary-tree/)**, Easy, 941 likes âœ”ï¸
- **[437. Path Sum III (è·¯å¾„æ€»å’Œ III)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/path-sum-iii/)**, Medium, 937 likes
- **[104. Maximum Depth of Binary Tree (äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-depth-of-binary-tree/)**, Easy, 937 likes âœ”ï¸
- **[237. Delete Node in a Linked List (åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/delete-node-in-a-linked-list/)**, Easy, 936 likes âœ”ï¸
- **[337. House Robber III (æ‰“å®¶åŠ«èˆ III)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/house-robber-iii/)**, Medium, 929 likes
- **[18. 4Sum (å››æ•°ä¹‹å’Œ)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/4sum/)**, Medium, 918 likes âœ”ï¸
- **[91. Decode Ways (è§£ç æ–¹æ³•)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/decode-ways/)**, Medium, 904 likes
- **[207. Course Schedule (è¯¾ç¨‹è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/course-schedule/)**, Medium, 897 likes
- **[37. Sudoku Solver (è§£æ•°ç‹¬)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sudoku-solver/)**, Hard, 897 likes âœ”ï¸
- **[175. Combine Two Tables (ç»„åˆä¸¤ä¸ªè¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/combine-two-tables/)**, Easy, 891 likes
- **[416. Partition Equal Subset Sum (åˆ†å‰²ç­‰å’Œå­é›†)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/partition-equal-subset-sum/)**, Medium, 886 likes
- **[238. Product of Array Except Self (é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/product-of-array-except-self/)**, Medium, 885 likes
- **[114. Flatten Binary Tree to Linked List (äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)**, Medium, 877 likes

[^1]: [&amp;#34;Definition of ALGORITHM&amp;#34;](https://www.merriam-webster.com/dictionary/algorithm). *Merriam-Webster Online Dictionary*. [Archived](https://web.archive.org/web/20200214074446/https://www.merriam-webster.com/dictionary/algorithm) from the original on February 14, 2020. Retrieved November 14, 2019.
    
[^2]: Introduction to Algorithm ä¸­æ–‡è¯‘ä½œã€Šç®—æ³•å¯¼è®ºã€‹
    
[^3]: ä¸»è¦å‚è€ƒæ–‡æ¡£ https://en.wikipedia.org/wiki/Binary_search_algorithm
    
[^4]: å›¾ç‰‡åŠæ¦‚å¿µå‡æ‘˜è‡ª Introduction to Algorithm 4thï¼Œ3.1èŠ‚ï¼Œ3.2 èŠ‚
    
[^5]: å›¾ç‰‡å¼•ç”¨è‡ª wikipedia linkedlist æ¡ç›®ï¼Œhttps://en.wikipedia.org/wiki/Linked_list
    
[^6]: ä¹Ÿç§°ä¸º Pascal's triangle https://en.wikipedia.org/wiki/Pascal%27s_triangle
    
[^7]: [é€’å½’æ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—çš„æ—¶é—´å¤æ‚åº¦â€”â€”å‡ ç§ç®€æ´è¯æ˜ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/257214075)
    
[^8]: Fibonacci ä»‹ç»ï¼šhttps://en.wikipedia.org/wiki/Fibonacci_number
    
[^9]: [å‡ ç§è®¡ç®—Fibonacciæ•°åˆ—ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/165877869)
    
[^10]: å‡ ç§æ–æ³¢é‚£å¥‘æ•°åˆ—ç®—æ³•æ¯”è¾ƒ [Fast Fibonacci algorithms (nayuki.io)](https://www.nayuki.io/page/fast-fibonacci-algorithms)
    
[^11]: æˆ‘çŸ¥é“çš„æœ‰ C++ï¼ŒScala
    
[^12]: jdk ç‰ˆæœ¬æœ‰å…³ï¼Œ64 ä½ jdkï¼ŒæŒ‰ 8 å­—èŠ‚å¯¹é½
    
[^13]: æ±‰è¯ºå¡”å›¾ç‰‡èµ„æ–™å‡æ¥è‡ª https://en.wikipedia.org/wiki/Tower_of_Hanoi
    
[^14]: ä¸ä¸»å®šç†ç±»ä¼¼çš„è¿˜æœ‰ Akraâ€“Bazzi methodï¼Œhttps://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method
    
[^15]: é¾Ÿå…”èµ›è·‘åŠ¨ç”»æ¥è‡ªäº [Floyd&amp;#39;s Hare and Tortoise Algorithm Demo - One Step! Code (onestepcode.com)](https://onestepcode.com/floyd-hare-tortoise-algorithm-demo/)
    
[^16]: Josephus problem ä¸»è¦å‚è€ƒ https://en.wikipedia.org/wiki/Josephus_problem
    
[^17]: KMP ç®—æ³•ä¸­ next æ•°ç»„çš„è¯´æ˜ [KMPç®—æ³•çš„Nextæ•°ç»„è¯¦è§£ - å”å°å–µ - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/tangzhengyue/p/4315393.html)
